/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/enchant.js":
/*!**********************************!*\
  !*** ../node_modules/enchant.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionEventTarget: () => (/* binding */ ActionEventTarget),\n/* harmony export */   BinaryInputManager: () => (/* binding */ BinaryInputManager),\n/* harmony export */   BinaryInputSource: () => (/* binding */ BinaryInputSource),\n/* harmony export */   CanvasLayer: () => (/* binding */ CanvasLayer),\n/* harmony export */   CanvasScene: () => (/* binding */ CanvasScene),\n/* harmony export */   Class: () => (/* binding */ Class),\n/* harmony export */   Core: () => (/* binding */ Core),\n/* harmony export */   CustomEvent: () => (/* binding */ CustomEvent),\n/* harmony export */   DOMScene: () => (/* binding */ DOMScene),\n/* harmony export */   DOMSound: () => (/* binding */ DOMSound),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ENV: () => (/* binding */ ENV),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Entity: () => (/* binding */ Entity),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   EventTarget: () => (/* binding */ EventTarget),\n/* harmony export */   Game: () => (/* binding */ Game),\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   InputManager: () => (/* binding */ InputManager),\n/* harmony export */   InputSource: () => (/* binding */ InputSource),\n/* harmony export */   KeyboardInputManager: () => (/* binding */ KeyboardInputManager),\n/* harmony export */   KeyboardInputSource: () => (/* binding */ KeyboardInputSource),\n/* harmony export */   Label: () => (/* binding */ Label),\n/* harmony export */   LoadingScene: () => (/* binding */ LoadingScene),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   ParallelAction: () => (/* binding */ ParallelAction),\n/* harmony export */   Scene: () => (/* binding */ Scene),\n/* harmony export */   Sprite: () => (/* binding */ Sprite),\n/* harmony export */   Surface: () => (/* binding */ Surface),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   Tween: () => (/* binding */ Tween),\n/* harmony export */   WebAudioSound: () => (/* binding */ WebAudioSound),\n/* harmony export */   enchant: () => (/* binding */ enchant)\n/* harmony export */ });\n/**\n * enchant.js v0.8.3\n * http://enchantjs.com\n *\n * Copyright UEI Corporation\n * Released under the MIT license.\n */\n\n// ECMA-262 5th edition Functions\nif (typeof Object.defineProperty !== 'function') {\n    Object.defineProperty = function(obj, prop, desc) {\n        if ('value' in desc) {\n            obj[prop] = desc.value;\n        }\n        if ('get' in desc) {\n            obj.__defineGetter__(prop, desc.get);\n        }\n        if ('set' in desc) {\n            obj.__defineSetter__(prop, desc.set);\n        }\n        return obj;\n    };\n}\nif (typeof Object.defineProperties !== 'function') {\n    Object.defineProperties = function(obj, descs) {\n        for (var prop in descs) {\n            if (descs.hasOwnProperty(prop)) {\n                Object.defineProperty(obj, prop, descs[prop]);\n            }\n        }\n        return obj;\n    };\n}\nif (typeof Object.create !== 'function') {\n    Object.create = function(prototype, descs) {\n        function F() {\n        }\n\n        F.prototype = prototype;\n        var obj = new F();\n        if (descs != null) {\n            Object.defineProperties(obj, descs);\n        }\n        return obj;\n    };\n}\nif (typeof Object.getPrototypeOf !== 'function') {\n    Object.getPrototypeOf = function(obj) {\n        return obj.__proto__;\n    };\n}\n\nif (typeof Function.prototype.bind !== 'function') {\n    Function.prototype.bind = function(thisObject) {\n        var func = this;\n        var args = Array.prototype.slice.call(arguments, 1);\n        var Nop = function() {\n        };\n        var bound = function() {\n            var a = args.concat(Array.prototype.slice.call(arguments));\n            return func.apply(\n                this instanceof Nop ? this : thisObject || window, a);\n        };\n        Nop.prototype = func.prototype;\n        bound.prototype = new Nop();\n        return bound;\n    };\n}\n\nwindow.getTime = (function() {\n    var origin;\n    if (window.performance && window.performance.now) {\n        origin = Date.now();\n        return function() {\n            return origin + window.performance.now();\n        };\n    } else if (window.performance && window.performance.webkitNow) {\n        origin = Date.now();\n        return function() {\n            return origin + window.performance.webkitNow();\n        };\n    } else {\n        return Date.now;\n    }\n}());\n\n// define requestAnimationFrame\nwindow.requestAnimationFrame =\n    window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    (function() {\n        var lastTime = window.getTime();\n        var frame = 1000 / 60;\n        return function(func) {\n            var _id = setTimeout(function() {\n                lastTime = window.getTime();\n                func(lastTime);\n            }, Math.max(0, lastTime + frame - window.getTime()));\n            return _id;\n        };\n    }());\n\n/**\n * Export the library classes globally.\n *\n * When no arguments are given, all classes defined in enchant.js as well as all classes defined in\n * plugins will be exported. When more than one argument is given, by default only classes defined\n * in enchant.js will be exported. When you wish to export plugin classes you must explicitly deliver\n * the plugin identifiers as arguments.\n *\n * @example\n * enchant();     // All classes will be exported.\n * enchant('');   // Only classes in enchant.js will be exported.\n * enchant('ui'); // enchant.js classes and ui.enchant.js classes will be exported.\n *\n * @param {...String} [modules] Export module. Multiple designations possible.\n * @function\n * @global\n * @name enchant\n */\nvar enchant = function(modules) {\n    if (modules != null) {\n        if (!(modules instanceof Array)) {\n            modules = Array.prototype.slice.call(arguments);\n        }\n        modules = modules.filter(function(module) {\n            return [module].join();\n        });\n    }\n    (function include(module, prefix) {\n        var submodules = [],\n            i, len;\n        for (var prop in module) {\n            if (module.hasOwnProperty(prop)) {\n                if (typeof module[prop] === 'function') {\n                    // window[prop] = module[prop];\n                } else if (typeof module[prop] === 'object' && module[prop] !== null && Object.getPrototypeOf(module[prop]) === Object.prototype) {\n                    if (modules == null) {\n                        submodules.push(prop);\n                    } else {\n                        i = modules.indexOf(prefix + prop);\n                        if (i !== -1) {\n                            submodules.push(prop);\n                            modules.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0, len = submodules.length; i < len; i++) {\n            include(module[submodules[i]], prefix + submodules[i] + '.');\n        }\n    }(enchant, ''));\n\n    // issue 185\n    // if (enchant.Class.getInheritanceTree(window.Game).length <= enchant.Class.getInheritanceTree(window.Core).length) {\n    //     window.Game = window.Core;\n    // }\n\n    if (modules != null && modules.length) {\n        throw new Error('Cannot load module: ' + modules.join(', '));\n    }\n};\n\n// export enchant\nwindow.enchant = enchant;\n\nwindow.addEventListener(\"message\", function(msg, origin) {\n    try {\n        var data = JSON.parse(msg.data);\n        if (data.type === \"event\") {\n            enchant.Core.instance.dispatchEvent(new enchant.Event(data.value));\n        } else if (data.type === \"debug\") {\n            switch (data.value) {\n                case \"start\":\n                    enchant.Core.instance.start();\n                    break;\n                case \"pause\":\n                    enchant.Core.instance.pause();\n                    break;\n                case \"resume\":\n                    enchant.Core.instance.resume();\n                    break;\n                case \"tick\":\n                    enchant.Core.instance._tick();\n                    break;\n                default:\n                    break;\n            }\n        }\n    } catch (e) {\n        // ignore\n    }\n}, false);\n\n/**\n * @name enchant.Class\n * @class\n * A Class representing a class which supports inheritance.\n * @param {Function} [superclass] The class from which the\n * new class will inherit the class definition.\n * @param {*} [definition] Class definition.\n * @constructor\n */\nenchant.Class = function(superclass, definition) {\n    return enchant.Class.create(superclass, definition);\n};\n\n/**\n * Creates a class.\n *\n * When defining a class that extends from another class, \n * the constructor of the other class will be used by default.\n * Even if you override this constructor, you must still call it\n * to ensure that the class is initialized correctly.\n *\n * @example\n * // Creates a Ball class.\n * var Ball = Class.create({ \n *\n *     // Ball's constructor\n *     initialize: function(radius) {\n *       // ... code ...\n *     }, \n *\n *     // Defines a fall method that doesn't take any arguments.\n *     fall: function() { \n *       // ... code ...\n *     }\n * });\n *\n * // Creates a Ball class that extends from \"Sprite\"\n * var Ball = Class.create(Sprite);  \n *\n * // Creates a Ball class that extends from \"Sprite\"\n * var Ball = Class.create(Sprite, { \n *\n *     // Overwrite Sprite's constructor\n *     initialize: function(radius) { \n *\n *         // Call Sprite's constructor.\n *         Sprite.call(this, radius * 2, radius * 2);\n *\n *         this.image = core.assets['ball.gif'];\n *     }\n * });\n *\n * @param {Function} [superclass] The class from which the\n * new class will inherit the class definition.\n * @param {*} [definition] Class definition.\n * @static\n */\nenchant.Class.create = function(superclass, definition) {\n    if (superclass == null && definition) {\n        throw new Error(\"superclass is undefined (enchant.Class.create)\");\n    } else if (superclass == null) {\n        throw new Error(\"definition is undefined (enchant.Class.create)\");\n    }\n\n    if (arguments.length === 0) {\n        return enchant.Class.create(Object, definition);\n    } else if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n        return enchant.Class.create(Object, arguments[0]);\n    }\n\n    for (var prop in definition) {\n        if (definition.hasOwnProperty(prop)) {\n            if (typeof definition[prop] === 'object' && definition[prop] !== null && Object.getPrototypeOf(definition[prop]) === Object.prototype) {\n                if (!('enumerable' in definition[prop])) {\n                    definition[prop].enumerable = true;\n                }\n            } else {\n                definition[prop] = { value: definition[prop], enumerable: true, writable: true };\n            }\n        }\n    }\n    var Constructor = function() {\n        if (this instanceof Constructor) {\n            Constructor.prototype.initialize.apply(this, arguments);\n        } else {\n            return new Constructor();\n        }\n    };\n    Constructor.prototype = Object.create(superclass.prototype, definition);\n    Constructor.prototype.constructor = Constructor;\n    if (Constructor.prototype.initialize == null) {\n        Constructor.prototype.initialize = function() {\n            superclass.apply(this, arguments);\n        };\n    }\n\n    var tree = this.getInheritanceTree(superclass);\n    for (var i = 0, l = tree.length; i < l; i++) {\n        if (typeof tree[i]._inherited === 'function') {\n            tree[i]._inherited(Constructor);\n            break;\n        }\n    }\n\n    return Constructor;\n};\n\n/**\n * Get the inheritance tree of this class.\n * @param {Function} Constructor\n * @return {Function[]} Parent's constructor\n */\nenchant.Class.getInheritanceTree = function(Constructor) {\n    var ret = [];\n    var C = Constructor;\n    var proto = C.prototype;\n    while (C !== Object) {\n        ret.push(C);\n        proto = Object.getPrototypeOf(proto);\n        C = proto.constructor;\n    }\n    return ret;\n};\n\n/**\n * @namespace\n * enchant.js environment variables.\n * Execution settings can be changed by modifying these before calling new Core().\n */\nenchant.ENV = {\n    /**\n     * Version of enchant.js\n     * @type String\n     */\n    VERSION: '0.8.3',\n    /**\n     * Identifier of the current browser.\n     * @type String\n     */\n    BROWSER: (function(ua) {\n        if (/Eagle/.test(ua)) {\n            return 'eagle';\n        } else if (/Opera/.test(ua)) {\n            return 'opera';\n        } else if (/MSIE|Trident/.test(ua)) {\n            return 'ie';\n        } else if (/Chrome/.test(ua)) {\n            return 'chrome';\n        } else if (/(?:Macintosh|Windows).*AppleWebKit/.test(ua)) {\n            return 'safari';\n        } else if (/(?:iPhone|iPad|iPod).*AppleWebKit/.test(ua)) {\n            return 'mobilesafari';\n        } else if (/Firefox/.test(ua)) {\n            return 'firefox';\n        } else if (/Android/.test(ua)) {\n            return 'android';\n        } else {\n            return '';\n        }\n    }(navigator.userAgent)),\n    /**\n     * The CSS vendor prefix of the current browser.\n     * @type String\n     */\n    VENDOR_PREFIX: (function() {\n        var ua = navigator.userAgent;\n        if (ua.indexOf('Opera') !== -1) {\n            return 'O';\n        } else if (/MSIE|Trident/.test(ua)) {\n            return 'ms';\n        } else if (ua.indexOf('WebKit') !== -1) {\n            return 'webkit';\n        } else if (navigator.product === 'Gecko') {\n            return 'Moz';\n        } else {\n            return '';\n        }\n    }()),\n    /**\n     * Determines if the current browser supports touch.\n     * True, if touch is enabled.\n     * @type Boolean\n     */\n    TOUCH_ENABLED: (function() {\n        var div = document.createElement('div');\n        div.setAttribute('ontouchstart', 'return');\n        return typeof div.ontouchstart === 'function';\n    }()),\n    /**\n     * Determines if the current browser is an iPhone with a retina display.\n     * True, if this display is a retina display.\n     * @type Boolean\n     */\n    RETINA_DISPLAY: (function() {\n        if (navigator.userAgent.indexOf('iPhone') !== -1 && window.devicePixelRatio === 2) {\n            var viewport = document.querySelector('meta[name=\"viewport\"]');\n            if (viewport == null) {\n                viewport = document.createElement('meta');\n                document.head.appendChild(viewport);\n            }\n            viewport.setAttribute('content', 'width=640');\n            return true;\n        } else {\n            return false;\n        }\n    }()),\n    /**\n     * Determines if for current browser Flash should be used to play \n     * sound instead of the native audio class.\n     * True, if flash should be used.\n     * @type Boolean\n     */\n    USE_FLASH_SOUND: (function() {\n        var ua = navigator.userAgent;\n        var vendor = navigator.vendor || \"\";\n        // non-local access, not on mobile mobile device, not on safari\n        return (location.href.indexOf('http') === 0 && ua.indexOf('Mobile') === -1 && vendor.indexOf('Apple') !== -1);\n    }()),\n    /**\n     * If click/touch event occure for these tags the setPreventDefault() method will not be called.\n     * @type String[]\n     */\n    USE_DEFAULT_EVENT_TAGS: ['input', 'textarea', 'select', 'area'],\n    /**\n     * Method names of CanvasRenderingContext2D that will be defined as Surface method.\n     * @type String[]\n     */\n    CANVAS_DRAWING_METHODS: [\n        'putImageData', 'drawImage', 'drawFocusRing', 'fill', 'stroke',\n        'clearRect', 'fillRect', 'strokeRect', 'fillText', 'strokeText'\n    ],\n    /**\n     * Keybind Table.\n     * You can use 'left', 'up', 'right', 'down' for preset event.\n     * @example\n     * enchant.ENV.KEY_BIND_TABLE = {\n     *     37: 'left',\n     *     38: 'up',\n     *     39: 'right',\n     *     40: 'down',\n     *     32: 'a', //-> use 'space' key as 'a button'\n     * };\n     * @type Object\n     */\n    KEY_BIND_TABLE: {\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down'\n    },\n    /**\n     * If keydown event occure for these keycodes the setPreventDefault() method will be called.\n     * @type Number[]\n     */\n    PREVENT_DEFAULT_KEY_CODES: [37, 38, 39, 40],\n    /**\n     * Determines if Sound is enabled on Mobile Safari.\n     * @type Boolean\n     */\n    SOUND_ENABLED_ON_MOBILE_SAFARI: true,\n    /**\n     * Determines if \"touch to start\" scene is enabled.\n     * It is necessary on Mobile Safari because WebAudio Sound is\n     * muted by browser until play any sound in touch event handler.\n     * If set it to false, you should control this behavior manually.\n     * @type Boolean\n     */\n    USE_TOUCH_TO_START_SCENE: true,\n    /**\n     * Determines if WebAudioAPI is enabled. (true: use WebAudioAPI instead of Audio element if possible)\n     * @type Boolean\n     */\n    USE_WEBAUDIO: (function() {\n        return location.protocol !== 'file:';\n    }()),\n    /**\n     * Determines if animation feature is enabled. (true: Timeline instance will be generated in new Node)\n     * @type Boolean\n     */\n    USE_ANIMATION: true,\n    /**\n     * Specifies range of the touch detection.\n     * The detection area will be (COLOR_DETECTION_LEVEL * 2 + 1)px square.\n     * @type Boolean\n     */\n    COLOR_DETECTION_LEVEL: 2\n};\n\n/**\n * @scope enchant.Event.prototype\n */\nenchant.Event = enchant.Class.create({\n    /**\n     * @name enchant.Event\n     * @class\n     * A class for an independent implementation of events similar to DOM Events.\n     * Does not include phase concepts.\n     * @param {String} type Event type.\n     * @constructs\n     */\n    initialize: function(type) {\n        /**\n         * The type of the event.\n         * @type String\n         */\n        this.type = type;\n        /**\n         * The target of the event.\n         * @type *\n         */\n        this.target = null;\n        /**\n         * The x-coordinate of the event's occurrence.\n         * @type Number\n         */\n        this.x = 0;\n        /**\n         * The y-coordinate of the event's occurrence.\n         * @type Number\n         */\n        this.y = 0;\n        /**\n         * The x-coordinate of the event's occurrence relative to the object\n         * which issued the event.\n         * @type Number\n         */\n        this.localX = 0;\n        /**\n         * The y-coordinate of the event's occurrence relative to the object\n         * which issued the event.\n         * @type Number\n         */\n        this.localY = 0;\n    },\n    _initPosition: function(pageX, pageY) {\n        var core = enchant.Core.instance;\n        this.x = this.localX = (pageX - core._pageX) / core.scale;\n        this.y = this.localY = (pageY - core._pageY) / core.scale;\n    }\n});\n\n/**\n * An event dispatched once the core has finished loading.\n *\n * When preloading images, it is necessary to wait until preloading is complete\n * before starting the game.\n * Issued by: {@link enchant.Core}\n *\n * @example\n * var core = new Core(320, 320);\n * core.preload('player.gif');\n * core.onload = function() {\n *     ... // Describes initial core processing\n * };\n * core.start();\n * @type String\n */\nenchant.Event.LOAD = 'load';\n\n/**\n * An event dispatched when an error occurs.\n * Issued by: {@link enchant.Core}, {@link enchant.Surface}, {@link enchant.WebAudioSound}, {@link enchant.DOMSound}\n */\nenchant.Event.ERROR = 'error';\n\n/**\n * An event dispatched when the display size is changed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n @type String\n */\nenchant.Event.CORE_RESIZE = 'coreresize';\n\n/**\n * An event dispatched while the core is loading.\n * Dispatched each time an image is preloaded.\n * Issued by: {@link enchant.LoadingScene}\n * @type String\n */\nenchant.Event.PROGRESS = 'progress';\n\n/**\n * An event which is occurring when a new frame is beeing processed.\n * Issued object: {@link enchant.Core}, {@link enchant.Node}\n * @type String\n */\nenchant.Event.ENTER_FRAME = 'enterframe';\n\n/**\n * An event dispatched at the end of processing a new frame.\n * Issued by: {@link enchant.Core}, {@link enchant.Node}\n * @type String\n */\nenchant.Event.EXIT_FRAME = 'exitframe';\n\n/**\n * An event dispatched when a Scene begins.\n * Issued by: {@link enchant.Scene}\n * @type String\n */\nenchant.Event.ENTER = 'enter';\n\n/**\n * An event dispatched when a Scene ends.\n * Issued by: {@link enchant.Scene}\n * @type String\n */\nenchant.Event.EXIT = 'exit';\n\n/**\n * An event dispatched when a Child is added to a Node.\n * Issued by: {@link enchant.Group}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.CHILD_ADDED = 'childadded';\n\n/**\n * An event dispatched when a Node is added to a Group.\n * Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.ADDED = 'added';\n\n/**\n * An event dispatched when a Node is added to a Scene.\n * Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.ADDED_TO_SCENE = 'addedtoscene';\n\n/**\n * An event dispatched when a Child is removed from a Node.\n * Issued by: {@link enchant.Group}, {@link enchant.Scene}\n * @type String\n * @type String\n */\nenchant.Event.CHILD_REMOVED = 'childremoved';\n\n/**\n * An event dispatched when a Node is deleted from a Group.\n * Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.REMOVED = 'removed';\n\n/**\n * An event dispatched when a Node is deleted from a Scene.\n * Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.REMOVED_FROM_SCENE = 'removedfromscene';\n\n/**\n * An event dispatched when a touch event intersecting a Node begins.\n * A mouse event counts as a touch event. Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.TOUCH_START = 'touchstart';\n\n/**\n * An event dispatched when a touch event intersecting the Node has been moved.\n * A mouse event counts as a touch event. Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.TOUCH_MOVE = 'touchmove';\n\n/**\n * An event dispatched when a touch event intersecting the Node ends.\n * A mouse event counts as a touch event. Issued by: {@link enchant.Node}\n * @type String\n */\nenchant.Event.TOUCH_END = 'touchend';\n\n/**\n * An event dispatched when an Entity is rendered.\n * Issued by: {@link enchant.Entity}\n * @type String\n */\nenchant.Event.RENDER = 'render';\n\n/**\n * An event dispatched when a button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.INPUT_START = 'inputstart';\n\n/**\n * An event dispatched when button inputs change.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.INPUT_CHANGE = 'inputchange';\n\n/**\n * An event dispatched when button input ends.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.INPUT_END = 'inputend';\n\n/**\n * An internal event which is occurring when a input changes.\n * Issued object: {@link enchant.InputSource}\n * @type String\n */\nenchant.Event.INPUT_STATE_CHANGED = 'inputstatechanged';\n\n/**\n * An event dispatched when the 'left' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.LEFT_BUTTON_DOWN = 'leftbuttondown';\n\n/**\n * An event dispatched when the 'left' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.LEFT_BUTTON_UP = 'leftbuttonup';\n\n/**\n * An event dispatched when the 'right' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.RIGHT_BUTTON_DOWN = 'rightbuttondown';\n\n/**\n * An event dispatched when the 'right' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.RIGHT_BUTTON_UP = 'rightbuttonup';\n\n/**\n * An event dispatched when the 'up' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.UP_BUTTON_DOWN = 'upbuttondown';\n\n/**\n * An event dispatched when the 'up' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.UP_BUTTON_UP = 'upbuttonup';\n\n/**\n * An event dispatched when the 'down' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.DOWN_BUTTON_DOWN = 'downbuttondown';\n\n/**\n * An event dispatched when the 'down' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.DOWN_BUTTON_UP = 'downbuttonup';\n\n/**\n * An event dispatched when the 'a' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.A_BUTTON_DOWN = 'abuttondown';\n\n/**\n * An event dispatched when the 'a' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.A_BUTTON_UP = 'abuttonup';\n\n/**\n * An event dispatched when the 'b' button is pressed.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.B_BUTTON_DOWN = 'bbuttondown';\n\n/**\n * An event dispatched when the 'b' button is released.\n * Issued by: {@link enchant.Core}, {@link enchant.Scene}\n * @type String\n */\nenchant.Event.B_BUTTON_UP = 'bbuttonup';\n\n/**\n * An event dispatched when an Action is added to a Timeline.\n * When looped, an Action is removed from the Timeline and added back into it.\n * @type String\n */\nenchant.Event.ADDED_TO_TIMELINE = \"addedtotimeline\";\n\n/**\n * An event dispatched when an Action is removed from a Timeline.\n * When looped, an Action is removed from the timeline and added back into it.\n * @type String\n */\nenchant.Event.REMOVED_FROM_TIMELINE = \"removedfromtimeline\";\n\n/**\n * An event dispatched when an Action begins.\n * @type String\n */\nenchant.Event.ACTION_START = \"actionstart\";\n\n/**\n * An event dispatched when an Action finishes.\n * @type String\n */\nenchant.Event.ACTION_END = \"actionend\";\n\n/**\n * An event dispatched when an Action has gone through one frame.\n * @type String\n */\nenchant.Event.ACTION_TICK = \"actiontick\";\n\n/**\n * An event dispatched to the Timeline when an Action is added.\n * @type String\n */\nenchant.Event.ACTION_ADDED = \"actionadded\";\n\n/**\n * An event dispatched to the Timeline when an Action is removed.\n * @type String\n */\nenchant.Event.ACTION_REMOVED = \"actionremoved\";\n\n/**\n * An event dispatched when an animation finishes, meaning null element was encountered\n * Issued by: {@link enchant.Sprite}\n * @type String\n */\nenchant.Event.ANIMATION_END = \"animationend\";\n\n/**\n * @scope enchant.EventTarget.prototype\n */\nenchant.EventTarget = enchant.Class.create({\n    /**\n     * @name enchant.EventTarget\n     * @class\n     * A class for implementation of events similar to DOM Events.\n     * However, it does not include the concept of phases.\n     * @constructs\n     */\n    initialize: function() {\n        this._listeners = {};\n    },\n    /**\n     * Add a new event listener which will be executed when the event\n     * is dispatched.\n     * @param {String} type Type of the events.\n     * @param {Function(e:enchant.Event)} listener Event listener to be added.\n     */\n    addEventListener: function(type, listener) {\n        var listeners = this._listeners[type];\n        if (listeners == null) {\n            this._listeners[type] = [listener];\n        } else if (listeners.indexOf(listener) === -1) {\n            listeners.unshift(listener);\n\n        }\n    },\n    /**\n     * Synonym for addEventListener.\n     * @param {String} type Type of the events.\n     * @param {Function(e:enchant.Event)} listener Event listener to be added.\n     * @see enchant.EventTarget#addEventListener\n     */\n    on: function() {\n        this.addEventListener.apply(this, arguments);\n    },\n    /**\n     * Delete an event listener.\n     * @param {String} [type] Type of the events.\n     * @param {Function(e:enchant.Event)} listener Event listener to be deleted.\n     */\n    removeEventListener: function(type, listener) {\n        var listeners = this._listeners[type];\n        if (listeners != null) {\n            var i = listeners.indexOf(listener);\n            if (i !== -1) {\n                listeners.splice(i, 1);\n            }\n        }\n    },\n    /**\n     * Clear all defined event listeners of a given type.\n     * If no type is given, all listeners will be removed.\n     * @param {String} type Type of the events.\n     */\n    clearEventListener: function(type) {\n        if (type != null) {\n            delete this._listeners[type];\n        } else {\n            this._listeners = {};\n        }\n    },\n    /**\n     * Issue an event.\n     * @param {enchant.Event} e Event to be issued.\n     */\n    dispatchEvent: function(e) {\n        e.target = this;\n        e.localX = e.x - this._offsetX;\n        e.localY = e.y - this._offsetY;\n        if (this['on' + e.type] != null){\n            this['on' + e.type](e);\n        }\n        var listeners = this._listeners[e.type];\n        if (listeners != null) {\n            listeners = listeners.slice();\n            for (var i = 0, len = listeners.length; i < len; i++) {\n                listeners[i].call(this, e);\n            }\n        }\n    }\n});\n\n    var core;\n    /**\n     * @scope enchant.Core.prototype\n     */\n    enchant.Core = enchant.Class.create(enchant.EventTarget, {\n        /**\n         * @name enchant.Core\n         * @class\n         * A class for controlling the coreâ€™s main loop and scenes.\n         *\n         * There can be only one instance at a time. When the\n         * constructor is executed while an instance exists, the\n         * existing instance will be overwritten. The existing instance\n         * can be accessed from {@link enchant.Core.instance}.\n         *\n         * @param {Number} [width=320] The width of the core viewport.\n         * @param {Number} [height=320] The height of the core viewport.\n         * @constructs\n         * @extends enchant.EventTarget\n         */\n        initialize: function(width, height) {\n            if (window.document.body === null) {\n                // @TODO postpone initialization after window.onload\n                throw new Error(\"document.body is null. Please excute 'new Core()' in window.onload.\");\n            }\n\n            enchant.EventTarget.call(this);\n            var initial = true;\n            if (core) {\n                initial = false;\n                core.stop();\n            }\n            core = enchant.Core.instance = this;\n\n            this._calledTime = 0;\n            this._mousedownID = 0;\n            this._surfaceID = 0;\n            this._soundID = 0;\n\n            this._scenes = [];\n\n            width = width || 320;\n            height = height || 320;\n\n            var stage = document.getElementById('enchant-stage');\n            var scale, sWidth, sHeight;\n            if (!stage) {\n                stage = document.createElement('div');\n                stage.id = 'enchant-stage';\n                stage.style.position = 'absolute';\n\n                if (document.body.firstChild) {\n                    document.body.insertBefore(stage, document.body.firstChild);\n                } else {\n                    document.body.appendChild(stage);\n                }\n                scale = Math.min(\n                    window.innerWidth / width,\n                    window.innerHeight / height\n                );\n                this._pageX = stage.getBoundingClientRect().left;\n                this._pageY = stage.getBoundingClientRect().top;\n            } else {\n                var style = window.getComputedStyle(stage);\n                sWidth = parseInt(style.width, 10);\n                sHeight = parseInt(style.height, 10);\n                if (sWidth && sHeight) {\n                    scale = Math.min(\n                        sWidth / width,\n                        sHeight / height\n                    );\n                } else {\n                    scale = 1;\n                }\n                while (stage.firstChild) {\n                    stage.removeChild(stage.firstChild);\n                }\n                stage.style.position = 'relative';\n\n                var bounding = stage.getBoundingClientRect();\n                this._pageX = Math.round(window.scrollX || window.pageXOffset + bounding.left);\n                this._pageY = Math.round(window.scrollY || window.pageYOffset + bounding.top);\n            }\n            stage.style.fontSize = '12px';\n            stage.style.webkitTextSizeAdjust = 'none';\n            stage.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n            this._element = stage;\n\n            this.addEventListener('coreresize', this._oncoreresize);\n\n            this._width = width;\n            this._height = height;\n            this.scale = scale;\n\n            /**\n             * The frame rate of the core.\n             * @type Number\n             */\n            this.fps = 30;\n            /**\n             * The number of frames processed since the core was started.\n             * @type Number\n             */\n            this.frame = 0;\n            /**\n             * Indicates whether or not the core can be executed.\n             * @type Boolean\n             */\n            this.ready = false;\n            /**\n             * Indicates whether or not the core is currently running.\n             * @type Boolean\n             */\n            this.running = false;\n            /**\n             * Object which stores loaded assets using their paths as keys.\n             * @type Object\n             */\n            this.assets = {};\n            var assets = this._assets = [];\n            (function detectAssets(module) {\n                if (module.assets) {\n                    enchant.Core.instance.preload(module.assets);\n                }\n                for (var prop in module) {\n                    if (module.hasOwnProperty(prop)) {\n                        if (typeof module[prop] === 'object' && module[prop] !== null && Object.getPrototypeOf(module[prop]) === Object.prototype) {\n                            detectAssets(module[prop]);\n                        }\n                    }\n                }\n            }(enchant));\n\n            /**\n             * The Scene which is currently displayed. This Scene is on top of the Scene stack.\n             * @type enchant.Scene\n             */\n            this.currentScene = null;\n            /**\n             * The root Scene. The Scene at the bottom of the Scene stack.\n             * @type enchant.Scene\n             */\n            this.rootScene = new enchant.Scene();\n            this.pushScene(this.rootScene);\n            /**\n             * The Scene to be displayed during loading.\n             * @type enchant.Scene\n             */\n            this.loadingScene = new enchant.LoadingScene();\n\n            /**\n             [/lang:ja]\n             * Indicates whether or not {@link enchant.Core#start} has been called.\n             [/lang]\n             * @type Boolean\n             * @private\n             */\n            this._activated = false;\n\n            this._offsetX = 0;\n            this._offsetY = 0;\n\n            /**\n             * Object that saves the current input state for the core.\n             * @type Object\n             */\n            this.input = {};\n\n            this.keyboardInputManager = new enchant.KeyboardInputManager(window.document, this.input);\n            this.keyboardInputManager.addBroadcastTarget(this);\n            this._keybind = this.keyboardInputManager._binds;\n\n            if (!enchant.ENV.KEY_BIND_TABLE) {\n                enchant.ENV.KEY_BIND_TABLE = {};\n            }\n\n            for (var prop in enchant.ENV.KEY_BIND_TABLE) {\n                this.keybind(prop, enchant.ENV.KEY_BIND_TABLE[prop]);\n            }\n\n            if (initial) {\n                stage = enchant.Core.instance._element;\n                var evt;\n                document.addEventListener('keydown', function(e) {\n                    core.dispatchEvent(new enchant.Event('keydown'));\n                    if (enchant.ENV.PREVENT_DEFAULT_KEY_CODES.indexOf(e.keyCode) !== -1) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                }, true);\n\n                if (enchant.ENV.TOUCH_ENABLED) {\n                    stage.addEventListener('touchstart', function(e) {\n                        var tagName = (e.target.tagName).toLowerCase();\n                        if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                            e.preventDefault();\n                            if (!core.running) {\n                                e.stopPropagation();\n                            }\n                        }\n                    }, true);\n                    stage.addEventListener('touchmove', function(e) {\n                        var tagName = (e.target.tagName).toLowerCase();\n                        if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                            e.preventDefault();\n                            if (!core.running) {\n                                e.stopPropagation();\n                            }\n                        }\n                    }, true);\n                    stage.addEventListener('touchend', function(e) {\n                        var tagName = (e.target.tagName).toLowerCase();\n                        if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                            e.preventDefault();\n                            if (!core.running) {\n                                e.stopPropagation();\n                            }\n                        }\n                    }, true);\n                }\n                stage.addEventListener('mousedown', function(e) {\n                    var tagName = (e.target.tagName).toLowerCase();\n                    if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                        e.preventDefault();\n                        core._mousedownID++;\n                        if (!core.running) {\n                            e.stopPropagation();\n                        }\n                    }\n                }, true);\n                stage.addEventListener('mousemove', function(e) {\n                    var tagName = (e.target.tagName).toLowerCase();\n                    if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                        e.preventDefault();\n                        if (!core.running) {\n                            e.stopPropagation();\n                        }\n                    }\n                }, true);\n                stage.addEventListener('mouseup', function(e) {\n                    var tagName = (e.target.tagName).toLowerCase();\n                    if (enchant.ENV.USE_DEFAULT_EVENT_TAGS.indexOf(tagName) === -1) {\n                        e.preventDefault();\n                        if (!core.running) {\n                            e.stopPropagation();\n                        }\n                    }\n                }, true);\n                core._touchEventTarget = {};\n                if (enchant.ENV.TOUCH_ENABLED) {\n                    stage.addEventListener('touchstart', function(e) {\n                        var core = enchant.Core.instance;\n                        var evt = new enchant.Event(enchant.Event.TOUCH_START);\n                        var touches = e.changedTouches;\n                        var touch, target;\n                        for (var i = 0, l = touches.length; i < l; i++) {\n                            touch = touches[i];\n                            evt._initPosition(touch.pageX, touch.pageY);\n                            target = core.currentScene._determineEventTarget(evt);\n                            core._touchEventTarget[touch.identifier] = target;\n                            target.dispatchEvent(evt);\n                        }\n                    }, false);\n                    stage.addEventListener('touchmove', function(e) {\n                        var core = enchant.Core.instance;\n                        var evt = new enchant.Event(enchant.Event.TOUCH_MOVE);\n                        var touches = e.changedTouches;\n                        var touch, target;\n                        for (var i = 0, l = touches.length; i < l; i++) {\n                            touch = touches[i];\n                            target = core._touchEventTarget[touch.identifier];\n                            if (target) {\n                                evt._initPosition(touch.pageX, touch.pageY);\n                                target.dispatchEvent(evt);\n                            }\n                        }\n                    }, false);\n                    stage.addEventListener('touchend', function(e) {\n                        var core = enchant.Core.instance;\n                        var evt = new enchant.Event(enchant.Event.TOUCH_END);\n                        var touches = e.changedTouches;\n                        var touch, target;\n                        for (var i = 0, l = touches.length; i < l; i++) {\n                            touch = touches[i];\n                            target = core._touchEventTarget[touch.identifier];\n                            if (target) {\n                                evt._initPosition(touch.pageX, touch.pageY);\n                                target.dispatchEvent(evt);\n                                delete core._touchEventTarget[touch.identifier];\n                            }\n                        }\n                    }, false);\n                }\n                stage.addEventListener('mousedown', function(e) {\n                    var core = enchant.Core.instance;\n                    var evt = new enchant.Event(enchant.Event.TOUCH_START);\n                    evt._initPosition(e.pageX, e.pageY);\n                    var target = core.currentScene._determineEventTarget(evt);\n                    core._touchEventTarget[core._mousedownID] = target;\n                    target.dispatchEvent(evt);\n                }, false);\n                stage.addEventListener('mousemove', function(e) {\n                    var core = enchant.Core.instance;\n                    var evt = new enchant.Event(enchant.Event.TOUCH_MOVE);\n                    evt._initPosition(e.pageX, e.pageY);\n                    var target = core._touchEventTarget[core._mousedownID];\n                    if (target) {\n                        target.dispatchEvent(evt);\n                    }\n                }, false);\n                stage.addEventListener('mouseup', function(e) {\n                    var core = enchant.Core.instance;\n                    var evt = new enchant.Event(enchant.Event.TOUCH_END);\n                    evt._initPosition(e.pageX, e.pageY);\n                    var target = core._touchEventTarget[core._mousedownID];\n                    if (target) {\n                        target.dispatchEvent(evt);\n                    }\n                    delete core._touchEventTarget[core._mousedownID];\n                }, false);\n            }\n        },\n        /**\n         * The width of the core screen.\n         * @type Number\n         */\n        width: {\n            get: function() {\n                return this._width;\n            },\n            set: function(w) {\n                this._width = w;\n                this._dispatchCoreResizeEvent();\n            }\n        },\n        /**\n         * The height of the core screen.\n         * @type Number\n         */\n        height: {\n            get: function() {\n                return this._height;\n            },\n            set: function(h) {\n                this._height = h;\n                this._dispatchCoreResizeEvent();\n            }\n        },\n        /**\n         * The scaling of the core rendering.\n         * @type Number\n         */\n        scale: {\n            get: function() {\n                return this._scale;\n            },\n            set: function(s) {\n                this._scale = s;\n                this._dispatchCoreResizeEvent();\n            }\n        },\n        _dispatchCoreResizeEvent: function() {\n            var e = new enchant.Event('coreresize');\n            e.width = this._width;\n            e.height = this._height;\n            e.scale = this._scale;\n            this.dispatchEvent(e);\n        },\n        _oncoreresize: function(e) {\n            this._element.style.width = Math.floor(this._width * this._scale) + 'px';\n            this._element.style.height = Math.floor(this._height * this._scale) + 'px';\n            var scene;\n            for (var i = 0, l = this._scenes.length; i < l; i++) {\n                scene = this._scenes[i];\n                scene.dispatchEvent(e);\n            }\n        },\n        /**\n         * File preloader.\n         *\n         * Loads the files specified in the parameters when\n         * {@link enchant.Core#start} is called.\n         * When all files are loaded, a {@link enchant.Event.LOAD}\n         * event is dispatched from the Core object. Depending on the\n         * type of each file, different objects will be created and\n         * stored in {@link enchant.Core#assets} Variable.\n         *\n         * When an image file is loaded, a {@link enchant.Surface} is\n         * created. If a sound file is loaded, an {@link enchant.Sound}\n         * object is created. Any other file type will be accessible\n         * as a string.\n         *\n         * In addition, because this Surface object is created with\n         * {@link enchant.Surface.load}, it is not possible to\n         * manipulate the image directly.\n         * Refer to the {@link enchant.Surface.load} documentation.\n         *\n         * @example\n         * core.preload('player.gif');\n         * core.onload = function() {\n         *     var sprite = new Sprite(32, 32);\n         *     sprite.image = core.assets['player.gif']; // Access via path\n         *     ...\n         * };\n         * core.start();\n         *\n         * @param {...String|String[]} assets Path of images to be preloaded.\n         * Multiple settings possible.\n         * @return {enchant.Core} this\n         */\n        preload: function(assets) {\n            var a;\n            if (!(assets instanceof Array)) {\n                if (typeof assets === 'object') {\n                    a = [];\n                    for (var name in assets) {\n                        if (assets.hasOwnProperty(name)) {\n                            a.push([ assets[name], name ]);\n                        }\n                    }\n                    assets = a;\n                } else {\n                    assets = Array.prototype.slice.call(arguments);\n                }\n            }\n            Array.prototype.push.apply(this._assets, assets);\n            return this;\n        },\n        /**\n         * Loads a file.\n         *\n         * @param {String} src File path of the resource to be loaded.\n         * @param {String} [alias] Name you want to designate for the resource to be loaded.\n         * @param {Function} [callback] Function to be called if the file loads successfully.\n         * @param {Function} [onerror] Function to be called if the file fails to load.\n         * @return {enchant.Deferred}\n         */\n        load: function(src, alias, callback, onerror) {\n            var assetName;\n            if (typeof arguments[1] === 'string') {\n                assetName = alias;\n                callback = callback || function() {};\n                onerror = onerror || function() {};\n            } else {\n                assetName = src;\n                var tempCallback = callback;\n                callback = arguments[1] || function() {};\n                onerror = tempCallback || function() {};\n            }\n\n            var ext = enchant.Core.findExt(src);\n\n            return enchant.Deferred.next(function() {\n                var d = new enchant.Deferred();\n                var _callback = function(e) {\n                    d.call(e);\n                    callback.call(this, e);\n                };\n                var _onerror = function(e) {\n                    d.fail(e);\n                    onerror.call(this, e);\n                };\n                if (enchant.Core._loadFuncs[ext]) {\n                    enchant.Core.instance.assets[assetName] = enchant.Core._loadFuncs[ext](src, ext, _callback, _onerror);\n                } else {\n                    var req = new XMLHttpRequest();\n                    req.open('GET', src, true);\n                    req.onreadystatechange = function() {\n                        if (req.readyState === 4) {\n                            if (req.status !== 200 && req.status !== 0) {\n                                // throw new Error(req.status + ': ' + 'Cannot load an asset: ' + src);\n                                var e = new enchant.Event('error');\n                                e.message = req.status + ': ' + 'Cannot load an asset: ' + src;\n                                _onerror.call(enchant.Core.instance, e);\n                            }\n\n                            var type = req.getResponseHeader('Content-Type') || '';\n                            if (type.match(/^image/)) {\n                                core.assets[assetName] = enchant.Surface.load(src, _callback, _onerror);\n                            } else if (type.match(/^audio/)) {\n                                core.assets[assetName] = enchant.Sound.load(src, type, _callback, _onerror);\n                            } else {\n                                core.assets[assetName] = req.responseText;\n                                _callback.call(enchant.Core.instance, new enchant.Event('load'));\n                            }\n                        }\n                    };\n                    req.send(null);\n                }\n                return d;\n            });\n        },\n        /**\n         * Start the core.\n         *\n         * Sets the framerate of the {@link enchant.Core#currentScene}\n         * according to the value stored in {@link enchant.core#fps}. If\n         * there are images to preload, loading will begin and the\n         * loading screen will be displayed.\n         * @return {enchant.Deferred}\n         */\n        start: function(deferred) {\n            var onloadTimeSetter = function() {\n                this.frame = 0;\n                this.removeEventListener('load', onloadTimeSetter);\n            };\n            this.addEventListener('load', onloadTimeSetter);\n\n            this.currentTime = window.getTime();\n            this.running = true;\n            this.ready = true;\n\n            if (!this._activated) {\n                this._activated = true;\n                if (enchant.ENV.BROWSER === 'mobilesafari' &&\n                    enchant.ENV.USE_WEBAUDIO &&\n                    enchant.ENV.USE_TOUCH_TO_START_SCENE) {\n                    var d = new enchant.Deferred();\n                    var scene = this._createTouchToStartScene();\n                    scene.addEventListener(enchant.Event.TOUCH_START, function waitTouch() {\n                        this.removeEventListener(enchant.Event.TOUCH_START, waitTouch);\n                        var a = new enchant.WebAudioSound();\n                        a.buffer = enchant.WebAudioSound.audioContext.createBuffer(1, 1, 48000);\n                        a.play();\n                        core.removeScene(scene);\n                        core.start(d);\n                    }, false);\n                    core.pushScene(scene);\n                    return d;\n                }\n            }\n\n            this._requestNextFrame(0);\n\n            var ret = this._requestPreload()\n                .next(function() {\n                    enchant.Core.instance.loadingScene.dispatchEvent(new enchant.Event(enchant.Event.LOAD));\n                });\n\n            if (deferred) {\n                ret.next(function(arg) {\n                    deferred.call(arg);\n                })\n                .error(function(arg) {\n                    deferred.fail(arg);\n                });\n            }\n\n            return ret;\n        },\n        _requestPreload: function() {\n            var o = {};\n            var loaded = 0,\n                len = 0,\n                loadFunc = function() {\n                    var e = new enchant.Event('progress');\n                    e.loaded = ++loaded;\n                    e.total = len;\n                    core.loadingScene.dispatchEvent(e);\n                };\n            this._assets\n                .reverse()\n                .forEach(function(asset) {\n                    var src, name;\n                    if (asset instanceof Array) {\n                        src = asset[0];\n                        name = asset[1];\n                    } else {\n                        src = name = asset;\n                    }\n                    if (!o[name]) {\n                        o[name] = this.load(src, name, loadFunc);\n                        len++;\n                    }\n                }, this);\n\n            this.pushScene(this.loadingScene);\n            return enchant.Deferred.parallel(o);\n        },\n        _createTouchToStartScene: function() {\n            var label = new enchant.Label('Touch to Start'),\n                size = Math.round(core.width / 10),\n                scene = new enchant.Scene();\n\n            label.color = '#fff';\n            label.font = (size - 1) + 'px bold Helvetica,Arial,sans-serif';\n            label.textAlign = 'center';\n            label.width = core.width;\n            label.height = label._boundHeight;\n            label.y = (core.height - label.height) / 2;\n\n            scene.backgroundColor = '#000';\n            scene.addChild(label);\n\n            return scene;\n        },\n        /**\n         * Start application in debug mode.\n         *\n         * Core debug mode can be turned on even if the\n         * {@link enchant.Core#_debug} flag is already set to true.\n         * @return {enchant.Deferred}\n         */\n        debug: function() {\n            this._debug = true;\n            return this.start();\n        },\n        actualFps: {\n            get: function() {\n                return this._actualFps || this.fps;\n            }\n        },\n        /**\n         * Requests the next frame.\n         * @param {Number} delay Amount of time to delay before calling requestAnimationFrame.\n         * @private\n         */\n        _requestNextFrame: function(delay) {\n            if (!this.ready) {\n                return;\n            }\n            if (this.fps >= 60 || delay <= 16) {\n                this._calledTime = window.getTime();\n                window.requestAnimationFrame(this._callTick);\n            } else {\n                setTimeout(function() {\n                    var core = enchant.Core.instance;\n                    core._calledTime = window.getTime();\n                    window.requestAnimationFrame(core._callTick);\n                }, Math.max(0, delay));\n            }\n        },\n        /**\n         * Calls {@link enchant.Core#_tick}.\n         * @param {Number} time\n         * @private\n         */\n        _callTick: function(time) {\n            enchant.Core.instance._tick(time);\n        },\n        _tick: function(time) {\n            var e = new enchant.Event('enterframe');\n            var now = window.getTime();\n            var elapsed = e.elapsed = now - this.currentTime;\n            this.currentTime = now;\n\n            this._actualFps = elapsed > 0 ? (1000 / elapsed) : 0;\n\n            var nodes = this.currentScene.childNodes.slice();\n            var push = Array.prototype.push;\n            while (nodes.length) {\n                var node = nodes.pop();\n                node.age++;\n                node.dispatchEvent(e);\n                if (node.childNodes) {\n                    push.apply(nodes, node.childNodes);\n                }\n            }\n\n            this.currentScene.age++;\n            this.currentScene.dispatchEvent(e);\n            this.dispatchEvent(e);\n\n            this.dispatchEvent(new enchant.Event('exitframe'));\n            this.frame++;\n            now = window.getTime();\n            \n            this._requestNextFrame(1000 / this.fps - (now - this._calledTime));\n        },\n        getTime: function() {\n            return window.getTime();\n        },\n        /**\n         * Stops the core.\n         *\n         * The frame will not be updated, and player input will not be accepted anymore.\n         * Core can be restarted using {@link enchant.Core#resume}.\n         */\n        stop: function() {\n            this.ready = false;\n            this.running = false;\n        },\n        /**\n         * Stops the core.\n         *\n         * The frame will not be updated, and player input will not be accepted anymore.\n         * Core can be started again using {@link enchant.Core#resume}.\n         */\n        pause: function() {\n            this.ready = false;\n        },\n        /**\n         * Resumes core operations.\n         */\n        resume: function() {\n            if (this.ready) {\n                return;\n            }\n            this.currentTime = window.getTime();\n            this.ready = true;\n            this.running = true;\n            this._requestNextFrame(0);\n        },\n\n        /**\n         * Switches to a new Scene.\n         *\n         * Scenes are controlled using a stack, with the top scene on\n         * the stack being the one displayed.\n         * When {@link enchant.Core#pushScene} is executed, the Scene is\n         * placed top of the stack. Frames will be only updated for the\n         * Scene which is on the top of the stack.\n         *\n         * @param {enchant.Scene} scene The new scene to display.\n         * @return {enchant.Scene} The new Scene.\n         */\n        pushScene: function(scene) {\n            this._element.appendChild(scene._element);\n            if (this.currentScene) {\n                this.currentScene.dispatchEvent(new enchant.Event('exit'));\n            }\n            this.currentScene = scene;\n            this.currentScene.dispatchEvent(new enchant.Event('enter'));\n            return this._scenes.push(scene);\n        },\n        /**\n         * Ends the current Scene and returns to the previous Scene.\n         *\n         * Scenes are controlled using a stack, with the top scene on\n         * the stack being the one displayed.\n         * When {@link enchant.Core#popScene} is executed, the Scene at\n         * the top of the stack is removed and returned.\n         *\n         * @return {enchant.Scene} Removed Scene.\n         */\n        popScene: function() {\n            if (this.currentScene === this.rootScene) {\n                return this.currentScene;\n            }\n            this._element.removeChild(this.currentScene._element);\n            this.currentScene.dispatchEvent(new enchant.Event('exit'));\n            this.currentScene = this._scenes[this._scenes.length - 2];\n            this.currentScene.dispatchEvent(new enchant.Event('enter'));\n            return this._scenes.pop();\n        },\n        /**\n         * Overwrites the current Scene with a new Scene.\n         *\n         * Executes {@link enchant.Core#popScene} and {@link enchant.Core#pushScene}\n         * one after another to replace the current scene with the new scene.\n         *\n         * @param {enchant.Scene} scene The new scene with which to replace the current scene.\n         * @return {enchant.Scene} The new Scene.\n         */\n        replaceScene: function(scene) {\n            this.popScene();\n            return this.pushScene(scene);\n        },\n        /**\n         * Removes a Scene from the Scene stack.\n         *\n         * If the scene passed in as a parameter is not the current\n         * scene, the stack will be searched for the given scene.\n         * If the given scene does not exist anywhere in the stack,\n         * this method returns null.\n         *\n         * @param {enchant.Scene} scene Scene to be removed.\n         * @return {enchant.Scene} The deleted Scene.\n         */\n        removeScene: function(scene) {\n            if (this.currentScene === scene) {\n                return this.popScene();\n            } else {\n                var i = this._scenes.indexOf(scene);\n                if (i !== -1) {\n                    this._scenes.splice(i, 1);\n                    this._element.removeChild(scene._element);\n                    return scene;\n                } else {\n                    return null;\n                }\n            }\n        },\n        _buttonListener: function(e) {\n            this.currentScene.dispatchEvent(e);\n        },\n        /**\n         * Bind a key code to an enchant.js button.\n         *\n         * Binds the given key code to the given enchant.js button\n         * ('left', 'right', 'up', 'down', 'a', 'b').\n         *\n         * @param {Number} key Key code for the button to be bound.\n         * @param {String} button An enchant.js button.\n         * @return {enchant.Core} this\n         */\n        keybind: function(key, button) {\n            this.keyboardInputManager.keybind(key, button);\n            this.addEventListener(button + 'buttondown', this._buttonListener);\n            this.addEventListener(button + 'buttonup', this._buttonListener);\n            return this;\n        },\n        /**\n         * Delete the key binding for the given key.\n         *\n         * @param {Number} key Key code whose binding is to be deleted.\n         * @return {enchant.Core} this\n         */\n        keyunbind: function(key) {\n            var button = this._keybind[key];\n            this.keyboardInputManager.keyunbind(key);\n            this.removeEventListener(button + 'buttondown', this._buttonListener);\n            this.removeEventListener(button + 'buttonup', this._buttonListener);\n            return this;\n        },\n        changeButtonState: function(button, bool) {\n            this.keyboardInputManager.changeState(button, bool);\n        },\n        /**\n         * Get the core time (not actual) elapsed since {@link enchant.Core#start} was called.\n         * @return {Number} Time elapsed (in seconds).\n         */\n        getElapsedTime: function() {\n            return this.frame / this.fps;\n        }\n    });\n\n    /**\n     * Functions for loading assets of the corresponding file type.\n     * The loading functions must take the file path, extension and\n     * callback function as arguments, then return the appropriate\n     * class instance.\n     * @static\n     * @private\n     * @type Object\n     */\n    enchant.Core._loadFuncs = {};\n    enchant.Core._loadFuncs['jpg'] =\n        enchant.Core._loadFuncs['jpeg'] =\n            enchant.Core._loadFuncs['gif'] =\n                enchant.Core._loadFuncs['png'] =\n                    enchant.Core._loadFuncs['bmp'] = function(src, ext, callback, onerror) {\n                        return enchant.Surface.load(src, callback, onerror);\n                    };\n    enchant.Core._loadFuncs['mp3'] =\n        enchant.Core._loadFuncs['aac'] =\n            enchant.Core._loadFuncs['m4a'] =\n                enchant.Core._loadFuncs['wav'] =\n                    enchant.Core._loadFuncs['ogg'] = function(src, ext, callback, onerror) {\n                        return enchant.Sound.load(src, 'audio/' + ext, callback, onerror);\n                    };\n\n    /**\n     * Get the file extension from a path.\n     * @param {String} path file path.\n     * @return {*}\n     */\n    enchant.Core.findExt = function(path) {\n        var matched = path.match(/\\.\\w+$/);\n        if (matched && matched.length > 0) {\n            return matched[0].slice(1).toLowerCase();\n        }\n\n        // for data URI\n        if (path.indexOf('data:') === 0) {\n            return path.split(/[\\/;]/)[1].toLowerCase();\n        }\n        return null;\n    };\n\n    /**\n     * The current Core instance.\n     * @type enchant.Core\n     * @static\n     */\n    enchant.Core.instance = null;\n\n/**\n * @name enchant.Game\n * @class\n * enchant.Game is moved to {@link enchant.Core} from v0.6\n * @deprecated\n */\nenchant.Game = enchant.Core;\n\n/**\n * @scope enchant.InputManager.prototype\n */\nenchant.InputManager = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.InputManager\n     * @class\n     * Class for managing input.\n     * @param {*} valueStore object that store input state.\n     * @param {*} [source=this] source that will be added to event object.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function(valueStore, source) {\n        enchant.EventTarget.call(this);\n\n        /**\n         * Array that store event target.\n         * @type enchant.EventTarget[]\n         */\n        this.broadcastTarget = [];\n        /**\n         * Object that store input state.\n         * @type Object\n         */\n        this.valueStore = valueStore;\n        /**\n         * source that will be added to event object.\n         * @type Object\n         */\n        this.source = source || this;\n\n        this._binds = {};\n\n        this._stateHandler = function(e) {\n            var id = e.source.identifier;\n            var name = this._binds[id];\n            this.changeState(name, e.data);\n        }.bind(this);\n    },\n    /**\n     * Name specified input.\n     * Input can be watched by flag or event.\n     * @param {enchant.InputSource} inputSource input source.\n     * @param {String} name input name.\n     */\n    bind: function(inputSource, name) {\n        inputSource.addEventListener(enchant.Event.INPUT_STATE_CHANGED, this._stateHandler);\n        this._binds[inputSource.identifier] = name;\n    },\n    /**\n     * Remove binded name.\n     * @param {enchant.InputSource} inputSource input source.\n     */\n    unbind: function(inputSource) {\n        inputSource.removeEventListener(enchant.Event.INPUT_STATE_CHANGED, this._stateHandler);\n        delete this._binds[inputSource.identifier];\n    },\n    /**\n     * Add event target.\n     * @param {enchant.EventTarget} eventTarget broadcast target.\n     */\n    addBroadcastTarget: function(eventTarget) {\n        var i = this.broadcastTarget.indexOf(eventTarget);\n        if (i === -1) {\n            this.broadcastTarget.push(eventTarget);\n        }\n    },\n    /**\n     * Remove event target.\n     * @param {enchant.EventTarget} eventTarget broadcast target.\n     */\n    removeBroadcastTarget: function(eventTarget) {\n        var i = this.broadcastTarget.indexOf(eventTarget);\n        if (i !== -1) {\n            this.broadcastTarget.splice(i, 1);\n        }\n    },\n    /**\n     * Dispatch event to {@link enchant.InputManager#broadcastTarget}.\n     * @param {enchant.Event} e event.\n     */\n    broadcastEvent: function(e) {\n        var target = this.broadcastTarget;\n        for (var i = 0, l = target.length; i < l; i++) {\n            target[i].dispatchEvent(e);\n        }\n    },\n    /**\n     * Change state of input.\n     * @param {String} name input name.\n     * @param {*} data input state.\n     */\n    changeState: function(name, data) {\n    }\n});\n\n/**\n * @scope enchant.InputSource.prototype\n */\nenchant.InputSource = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.InputSource\n     * @class\n     * Class that wrap input.\n     * @param {String} identifier identifier of InputSource.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function(identifier) {\n        enchant.EventTarget.call(this);\n        /**\n         * identifier of InputSource.\n         * @type String\n         */\n        this.identifier = identifier;\n    },\n    /**\n     * Notify state change by event.\n     * @param {*} data state.\n     */\n    notifyStateChange: function(data) {\n        var e = new enchant.Event(enchant.Event.INPUT_STATE_CHANGED);\n        e.data = data;\n        e.source = this;\n        this.dispatchEvent(e);\n    }\n});\n\n/**\n * @scope enchant.BinaryInputManager.prototype\n */\nenchant.BinaryInputManager = enchant.Class.create(enchant.InputManager, {\n    /**\n     * @name enchant.BinaryInputManager\n     * @class\n     * Class for managing input.\n     * @param {*} flagStore object that store input flag.\n     * @param {String} activeEventNameSuffix event name suffix.\n     * @param {String} inactiveEventNameSuffix event name suffix.\n     * @param {*} [source=this] source that will be added to event object.\n     * @constructs\n     * @extends enchant.InputManager\n     */\n    initialize: function(flagStore, activeEventNameSuffix, inactiveEventNameSuffix, source) {\n        enchant.InputManager.call(this, flagStore, source);\n        /**\n         * The number of active inputs.\n         * @type Number\n         */\n        this.activeInputsNum = 0;\n        /**\n         * event name suffix that dispatched by BinaryInputManager.\n         * @type String\n         */\n        this.activeEventNameSuffix = activeEventNameSuffix;\n        /**\n         * event name suffix that dispatched by BinaryInputManager.\n         * @type String\n         */\n        this.inactiveEventNameSuffix = inactiveEventNameSuffix;\n    },\n    /**\n     * Name specified input.\n     * @param {enchant.BinaryInputSource} inputSource input source.\n     * @param {String} name input name.\n     * @see enchant.InputManager#bind\n     */\n    bind: function(binaryInputSource, name) {\n        enchant.InputManager.prototype.bind.call(this, binaryInputSource, name);\n        this.valueStore[name] = false;\n    },\n    /**\n     * Remove binded name.\n     * @param {enchant.BinaryInputSource} inputSource input source.\n     * @see enchant.InputManager#unbind\n     */\n    unbind: function(binaryInputSource) {\n        var name = this._binds[binaryInputSource.identifier];\n        enchant.InputManager.prototype.unbind.call(this, binaryInputSource);\n        delete this.valueStore[name];\n    },\n    /**\n     * Change state of input.\n     * @param {String} name input name.\n     * @param {Boolean} bool input state.\n     */\n    changeState: function(name, bool) {\n        if (bool) {\n            this._down(name);\n        } else {\n            this._up(name);\n        }\n    },\n    _down: function(name) {\n        var inputEvent;\n        if (!this.valueStore[name]) {\n            this.valueStore[name] = true;\n            inputEvent = new enchant.Event((this.activeInputsNum++) ? 'inputchange' : 'inputstart');\n            inputEvent.source = this.source;\n            this.broadcastEvent(inputEvent);\n        }\n        var downEvent = new enchant.Event(name + this.activeEventNameSuffix);\n        downEvent.source = this.source;\n        this.broadcastEvent(downEvent);\n    },\n    _up: function(name) {\n        var inputEvent;\n        if (this.valueStore[name]) {\n            this.valueStore[name] = false;\n            inputEvent = new enchant.Event((--this.activeInputsNum) ? 'inputchange' : 'inputend');\n            inputEvent.source = this.source;\n            this.broadcastEvent(inputEvent);\n        }\n        var upEvent = new enchant.Event(name + this.inactiveEventNameSuffix);\n        upEvent.source = this.source;\n        this.broadcastEvent(upEvent);\n    }\n});\n\n/**\n * @scope enchant.BinaryInputSource.prototype\n */\nenchant.BinaryInputSource = enchant.Class.create(enchant.InputSource, {\n    /**\n     * @name enchant.BinaryInputSource\n     * @class\n     * Class that wrap binary input.\n     * @param {String} identifier identifier of BinaryInputSource.\n     * @constructs\n     * @extends enchant.InputSource\n     */\n    initialize: function(identifier) {\n        enchant.InputSource.call(this, identifier);\n    }\n});\n\n/**\n * @scope enchant.KeyboardInputManager.prototype\n */\nenchant.KeyboardInputManager = enchant.Class.create(enchant.BinaryInputManager, {\n    /**\n     * @name enchant.KeyboardInputManager\n     * @class\n     * Class that manage keyboard input.\n     * @param {HTMLElement} dom element that will be watched.\n     * @param {*} flagStore object that store input flag.\n     * @constructs\n     * @extends enchant.BinaryInputManager\n     */\n    initialize: function(domElement, flagStore) {\n        enchant.BinaryInputManager.call(this, flagStore, 'buttondown', 'buttonup');\n        this._attachDOMEvent(domElement, 'keydown', true);\n        this._attachDOMEvent(domElement, 'keyup', false);\n    },\n    /**\n     * Call {@link enchant.BinaryInputManager#bind} with BinaryInputSource equivalent of key code.\n     * @param {Number} keyCode key code.\n     * @param {String} name input name.\n     */\n    keybind: function(keyCode, name) {\n        this.bind(enchant.KeyboardInputSource.getByKeyCode('' + keyCode), name);\n    },\n    /**\n     * Call {@link enchant.BinaryInputManager#unbind} with BinaryInputSource equivalent of key code.\n     * @param {Number} keyCode key code.\n     */\n    keyunbind: function(keyCode) {\n        this.unbind(enchant.KeyboardInputSource.getByKeyCode('' + keyCode));\n    },\n    _attachDOMEvent: function(domElement, eventType, state) {\n        domElement.addEventListener(eventType, function(e) {\n            var core = enchant.Core.instance;\n            if (!core || !core.running) {\n                return;\n            }\n            var code = e.keyCode;\n            var source = enchant.KeyboardInputSource._instances[code];\n            if (source) {\n                source.notifyStateChange(state);\n            }\n        }, true);\n    }\n});\n\n/**\n * @scope enchant.KeyboardInputSource.prototype\n */\nenchant.KeyboardInputSource = enchant.Class.create(enchant.BinaryInputSource, {\n    /**\n     * @name enchant.KeyboardInputSource\n     * @class\n     * @param {String} keyCode key code of BinaryInputSource.\n     * @constructs\n     * @extends enchant.BinaryInputSource\n     */\n    initialize: function(keyCode) {\n        enchant.BinaryInputSource.call(this, keyCode);\n    }\n});\n/**\n * @private\n */\nenchant.KeyboardInputSource._instances = {};\n/**\n * @static\n * Get the instance by key code.\n * @param {Number} keyCode key code.\n * @return {enchant.KeyboardInputSource} instance.\n */\nenchant.KeyboardInputSource.getByKeyCode = function(keyCode) {\n    if (!this._instances[keyCode]) {\n        this._instances[keyCode] = new enchant.KeyboardInputSource(keyCode);\n    }\n    return this._instances[keyCode];\n};\n\n/**\n * @scope enchant.Node.prototype\n */\nenchant.Node = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.Node\n     * @class\n     * Base class for objects in the display tree which is rooted at a Scene.\n     * Not to be used directly.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function() {\n        enchant.EventTarget.call(this);\n\n        this._dirty = false;\n\n        this._matrix = [ 1, 0, 0, 1, 0, 0 ];\n\n        this._x = 0;\n        this._y = 0;\n        this._offsetX = 0;\n        this._offsetY = 0;\n\n        /**\n         * The age (frames) of this node which will be increased before this node receives {@link enchant.Event.ENTER_FRAME} event.\n         * @type Number\n         */\n        this.age = 0;\n\n        /**\n         * Parent Node of this Node.\n         * @type enchant.Group\n         */\n        this.parentNode = null;\n        /**\n         * Scene to which Node belongs.\n         * @type enchant.Scene\n         */\n        this.scene = null;\n\n        this.addEventListener('touchstart', function(e) {\n            if (this.parentNode) {\n                this.parentNode.dispatchEvent(e);\n            }\n        });\n        this.addEventListener('touchmove', function(e) {\n            if (this.parentNode) {\n                this.parentNode.dispatchEvent(e);\n            }\n        });\n        this.addEventListener('touchend', function(e) {\n            if (this.parentNode) {\n                this.parentNode.dispatchEvent(e);\n            }\n        });\n\n        // NodeãŒç”Ÿæˆã•ã‚Œã‚‹éš›ã«, tl ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã« Timeline ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿½åŠ ã—ã¦ã„ã‚‹.\n        if (enchant.ENV.USE_ANIMATION) {\n            this.tl = new enchant.Timeline(this);\n        }\n    },\n    /**\n     * Move the Node to the given target location.\n     * @param {Number} x Target x coordinates.\n     * @param {Number} y Target y coordinates.\n     */\n    moveTo: function(x, y) {\n        this.x = x;\n        this.y = y;\n    },\n    /**\n     * Move the Node relative to its current position.\n     * @param {Number} x x axis movement distance.\n     * @param {Number} y y axis movement distance.\n     */\n    moveBy: function(x, y) {\n        this.x += x;\n        this.y += y;\n    },\n    /**\n     * x coordinates of the Node.\n     * @type Number\n     */\n    x: {\n        get: function() {\n            return this._x;\n        },\n        set: function(x) {\n            if(this._x !== x) {\n                this._x = x;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * y coordinates of the Node.\n     * @type Number\n     */\n    y: {\n        get: function() {\n            return this._y;\n        },\n        set: function(y) {\n            if(this._y !== y) {\n                this._y = y;\n                this._dirty = true;\n            }\n        }\n    },\n    _updateCoordinate: function() {\n        var node = this;\n        var tree = [ node ];\n        var parent = node.parentNode;\n        var scene = this.scene;\n        while (parent && node._dirty) {\n            tree.unshift(parent);\n            node = node.parentNode;\n            parent = node.parentNode;\n        }\n        var matrix = enchant.Matrix.instance;\n        var stack = matrix.stack;\n        var mat = [];\n        var newmat, ox, oy;\n        stack.push(tree[0]._matrix);\n        for (var i = 1, l = tree.length; i < l; i++) {\n            node = tree[i];\n            newmat = [];\n            matrix.makeTransformMatrix(node, mat);\n            matrix.multiply(stack[stack.length - 1], mat, newmat);\n            node._matrix = newmat;\n            stack.push(newmat);\n            ox = (typeof node._originX === 'number') ? node._originX : node._width / 2 || 0;\n            oy = (typeof node._originY === 'number') ? node._originY : node._height / 2 || 0;\n            var vec = [ ox, oy ];\n            matrix.multiplyVec(newmat, vec, vec);\n            node._offsetX = vec[0] - ox;\n            node._offsetY = vec[1] - oy;\n            node._dirty = false;\n        }\n        matrix.reset();\n    },\n    remove: function() {\n        if (this.parentNode) {\n            this.parentNode.removeChild(this);\n        }\n        if (this.childNodes) {\n            var childNodes = this.childNodes.slice();\n            for(var i = childNodes.length-1; i >= 0; i--) {\n                childNodes[i].remove();\n            }\n        }\n        \n        this.clearEventListener();\n    }\n});\n\nvar _intersectBetweenClassAndInstance = function(Class, instance) {\n    var ret = [];\n    var c;\n    for (var i = 0, l = Class.collection.length; i < l; i++) {\n        c = Class.collection[i];\n        if (instance._intersectOne(c)) {\n            ret.push(c);\n        }\n    }\n    return ret;\n};\n\nvar _intersectBetweenClassAndClass = function(Class1, Class2) {\n    var ret = [];\n    var c1, c2;\n    for (var i = 0, l = Class1.collection.length; i < l; i++) {\n        c1 = Class1.collection[i];\n        for (var j = 0, ll = Class2.collection.length; j < ll; j++) {\n            c2 = Class2.collection[j];\n            if (c1._intersectOne(c2)) {\n                ret.push([ c1, c2 ]);\n            }\n        }\n    }\n    return ret;\n};\n\nvar _intersectStrictBetweenClassAndInstance = function(Class, instance) {\n    var ret = [];\n    var c;\n    for (var i = 0, l = Class.collection.length; i < l; i++) {\n        c = Class.collection[i];\n        if (instance._intersectStrictOne(c)) {\n            ret.push(c);\n        }\n    }\n    return ret;\n};\n\nvar _intersectStrictBetweenClassAndClass = function(Class1, Class2) {\n    var ret = [];\n    var c1, c2;\n    for (var i = 0, l = Class1.collection.length; i < l; i++) {\n        c1 = Class1.collection[i];\n        for (var j = 0, ll = Class2.collection.length; j < ll; j++) {\n            c2 = Class2.collection[j];\n            if (c1._intersectStrictOne(c2)) {\n                ret.push([ c1, c2 ]);\n            }\n        }\n    }\n    return ret;\n};\n\nvar _staticIntersect = function(other) {\n    if (other instanceof enchant.Entity) {\n        return _intersectBetweenClassAndInstance(this, other);\n    } else if (typeof other === 'function' && other.collection) {\n        return _intersectBetweenClassAndClass(this, other);\n    }\n    return false;\n};\n\nvar _staticIntersectStrict = function(other) {\n    if (other instanceof enchant.Entity) {\n        return _intersectStrictBetweenClassAndInstance(this, other);\n    } else if (typeof other === 'function' && other.collection) {\n        return _intersectStrictBetweenClassAndClass(this, other);\n    }\n    return false;\n};\n\nvar _nodePrototypeClearEventListener = enchant.Node.prototype.clearEventListener;\n\n/**\n * @scope enchant.Entity.prototype\n */\nenchant.Entity = enchant.Class.create(enchant.Node, {\n    /**\n     * @name enchant.Entity\n     * @class\n     * A class with objects displayed as DOM elements. Not to be used directly.\n     * @constructs\n     * @extends enchant.Node\n     */\n    initialize: function() {\n        var core = enchant.Core.instance;\n        enchant.Node.call(this);\n\n        this._rotation = 0;\n        this._scaleX = 1;\n        this._scaleY = 1;\n\n        this._touchEnabled = true;\n        this._clipping = false;\n\n        this._originX = null;\n        this._originY = null;\n\n        this._width = 0;\n        this._height = 0;\n        this._backgroundColor = null;\n        this._debugColor = '#0000ff';\n        this._opacity = 1;\n        this._visible = true;\n        this._buttonMode = null;\n\n        this._style = {};\n        this.__styleStatus = {};\n\n        this._isContainedInCollection = false;\n\n        /**\n         * @type String\n         */\n        this.compositeOperation = null;\n\n        /**\n         * Defines this Entity as a button.\n         * When touched or clicked the corresponding button event is dispatched.\n         * Valid buttonModes are: left, right, up, down, a, b. \n         * @type String\n         */\n        this.buttonMode = null;\n        /**\n         * Indicates if this Entity is being clicked.\n         * Only works when {@link enchant.Entity.buttonMode} is set.\n         * @type Boolean\n         */\n        this.buttonPressed = false;\n        this.addEventListener('touchstart', function() {\n            if (!this.buttonMode) {\n                return;\n            }\n            this.buttonPressed = true;\n            this.dispatchEvent(new enchant.Event(this.buttonMode + 'buttondown'));\n            core.changeButtonState(this.buttonMode, true);\n        });\n        this.addEventListener('touchend', function() {\n            if (!this.buttonMode) {\n                return;\n            }\n            this.buttonPressed = false;\n            this.dispatchEvent(new enchant.Event(this.buttonMode + 'buttonup'));\n            core.changeButtonState(this.buttonMode, false);\n        });\n\n        this.enableCollection();\n    },\n    /**\n     * The width of the Entity.\n     * @type Number\n     */\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            if(this._width !== width) {\n                this._width = width;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * The height of the Entity.\n     * @type Number\n     */\n    height: {\n        get: function() {\n            return this._height;\n        },\n        set: function(height) {\n            if(this._height !== height) {\n                this._height = height;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * The Entity background color.\n     * Must be provided in the same format as the CSS 'color' property.\n     * @type String\n     */\n    backgroundColor: {\n        get: function() {\n            return this._backgroundColor;\n        },\n        set: function(color) {\n            this._backgroundColor = color;\n        }\n    },\n    /**\n     * The Entity debug color.\n     * Must be provided in the same format as the CSS 'color' property.\n     * @type String\n     */\n    debugColor: {\n        get: function() {\n            return this._debugColor;\n        },\n        set: function(color) {\n            this._debugColor = color;\n        }\n    },\n    /**\n     * The transparency of this entity.\n     * Defines the transparency level from 0 to 1\n     * (0 is completely transparent, 1 is completely opaque).\n     * @type Number\n     */\n    opacity: {\n        get: function() {\n            return this._opacity;\n        },\n        set: function(opacity) {\n            this._opacity = parseFloat(opacity);\n        }\n    },\n    /**\n     * Indicates whether or not to display this Entity.\n     * @type Boolean\n     */\n    visible: {\n        get: function() {\n            return this._visible;\n        },\n        set: function(visible) {\n            this._visible = visible;\n        }\n    },\n    /**\n     * Indicates whether or not this Entity can be touched.\n     * @type Boolean\n     */\n    touchEnabled: {\n        get: function() {\n            return this._touchEnabled;\n        },\n        set: function(enabled) {\n            this._touchEnabled = enabled;\n            if (enabled) {\n                this._style.pointerEvents = 'all';\n            } else {\n                this._style.pointerEvents = 'none';\n            }\n        }\n    },\n    /**\n     * Performs a collision detection based on whether or not the bounding rectangles are intersecting.\n     * @param {*} other An object like Entity, with the properties x, y, width, height, which are used for the \n     * collision detection.\n     * @return {Boolean} True, if a collision was detected.\n     */\n    intersect: function(other) {\n        if (other instanceof enchant.Entity) {\n            return this._intersectOne(other);\n        } else if (typeof other === 'function' && other.collection) {\n            return _intersectBetweenClassAndInstance(other, this);\n        }\n        return false;\n    },\n    _intersectOne: function(other) {\n        if (this._dirty) {\n            this._updateCoordinate();\n        } if (other._dirty) {\n            other._updateCoordinate();\n        }\n        return this._offsetX < other._offsetX + other.width && other._offsetX < this._offsetX + this.width &&\n            this._offsetY < other._offsetY + other.height && other._offsetY < this._offsetY + this.height;\n    },\n    intersectStrict: function(other) {\n        if (other instanceof enchant.Entity) {\n            return this._intersectStrictOne(other);\n        } else if (typeof other === 'function' && other.collection) {\n            return _intersectStrictBetweenClassAndInstance(other, this);\n        }\n        return false;\n    },\n    _intersectStrictOne: function(other) {\n        if (this._dirty) {\n            this._updateCoordinate();\n        } if (other._dirty) {\n            other._updateCoordinate();\n        }\n        var rect1 = this.getOrientedBoundingRect(),\n            rect2 = other.getOrientedBoundingRect(),\n            lt1 = rect1.leftTop, rt1 = rect1.rightTop,\n            lb1 = rect1.leftBottom, rb1 = rect1.rightBottom,\n            lt2 = rect2.leftTop, rt2 = rect2.rightTop,\n            lb2 = rect2.leftBottom, rb2 = rect2.rightBottom,\n            ltx1 = lt1[0], lty1 = lt1[1], rtx1 = rt1[0], rty1 = rt1[1],\n            lbx1 = lb1[0], lby1 = lb1[1], rbx1 = rb1[0], rby1 = rb1[1],\n            ltx2 = lt2[0], lty2 = lt2[1], rtx2 = rt2[0], rty2 = rt2[1],\n            lbx2 = lb2[0], lby2 = lb2[1], rbx2 = rb2[0], rby2 = rb2[1],\n            t1 = [ rtx1 - ltx1, rty1 - lty1 ],\n            r1 = [ rbx1 - rtx1, rby1 - rty1 ],\n            b1 = [ lbx1 - rbx1, lby1 - rby1 ],\n            l1 = [ ltx1 - lbx1, lty1 - lby1 ],\n            t2 = [ rtx2 - ltx2, rty2 - lty2 ],\n            r2 = [ rbx2 - rtx2, rby2 - rty2 ],\n            b2 = [ lbx2 - rbx2, lby2 - rby2 ],\n            l2 = [ ltx2 - lbx2, lty2 - lby2 ],\n            cx1 = (ltx1 + rtx1 + lbx1 + rbx1) >> 2,\n            cy1 = (lty1 + rty1 + lby1 + rby1) >> 2,\n            cx2 = (ltx2 + rtx2 + lbx2 + rbx2) >> 2,\n            cy2 = (lty2 + rty2 + lby2 + rby2) >> 2,\n            i, j, poss1, poss2, dirs1, dirs2, pos1, pos2, dir1, dir2,\n            px1, py1, px2, py2, dx1, dy1, dx2, dy2, vx, vy, c, c1, c2;\n        if (t1[0] * (cy2 - lty1) - t1[1] * (cx2 - ltx1) > 0 &&\n            r1[0] * (cy2 - rty1) - r1[1] * (cx2 - rtx1) > 0 &&\n            b1[0] * (cy2 - rby1) - b1[1] * (cx2 - rbx1) > 0 &&\n            l1[0] * (cy2 - lby1) - l1[1] * (cx2 - lbx1) > 0) {\n            return true;\n        } else if (t2[0] * (cy1 - lty2) - t2[1] * (cx1 - ltx2) > 0 &&\n            r2[0] * (cy1 - rty2) - r2[1] * (cx1 - rtx2) > 0 &&\n            b2[0] * (cy1 - rby2) - b2[1] * (cx1 - rbx2) > 0 &&\n            l2[0] * (cy1 - lby2) - l2[1] * (cx1 - lbx2) > 0) {\n            return true;\n        } else {\n            poss1 = [ lt1, rt1, rb1, lb1 ];\n            poss2 = [ lt2, rt2, rb2, lb2 ];\n            dirs1 = [ t1, r1, b1, l1 ];\n            dirs2 = [ t2, r2, b2, l2 ];\n            for (i = 0; i < 4; i++) {\n                pos1 = poss1[i];\n                px1 = pos1[0]; py1 = pos1[1];\n                dir1 = dirs1[i];\n                dx1 = dir1[0]; dy1 = dir1[1];\n                for (j = 0; j < 4; j++) {\n                    pos2 = poss2[j];\n                    px2 = pos2[0]; py2 = pos2[1];\n                    dir2 = dirs2[j];\n                    dx2 = dir2[0]; dy2 = dir2[1];\n                    c = dx1 * dy2 - dy1 * dx2;\n                    if (c !== 0) {\n                        vx = px2 - px1;\n                        vy = py2 - py1;\n                        c1 = (vx * dy1 - vy * dx1) / c;\n                        c2 = (vx * dy2 - vy * dx2) / c;\n                        if (0 < c1 && c1 < 1 && 0 < c2 && c2 < 1) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    },\n    /**\n     * Performs a collision detection based on distance from the Entity's central point.\n     * @param {*} other An object like Entity, with properties x, y, width, height, which are used for the \n     * collision detection.\n     * @param {Number} [distance] The greatest distance to be considered for a collision.\n     * The default distance is the average of both objects width and height.\n     * @return {Boolean} True, if a collision was detected.\n     */\n    within: function(other, distance) {\n        if (this._dirty) {\n            this._updateCoordinate();\n        } if (other._dirty) {\n            other._updateCoordinate();\n        }\n        if (distance == null) {\n            distance = (this.width + this.height + other.width + other.height) / 4;\n        }\n        var _;\n        return (_ = this._offsetX - other._offsetX + (this.width - other.width) / 2) * _ +\n            (_ = this._offsetY - other._offsetY + (this.height - other.height) / 2) * _ < distance * distance;\n    },\n    /**\n     * Enlarges or shrinks this Entity.\n     * @param {Number} x Scaling factor on the x axis.\n     * @param {Number} [y] Scaling factor on the y axis.\n     */\n    scale: function(x, y) {\n        this._scaleX *= x;\n        this._scaleY *= (y != null) ? y : x;\n        this._dirty = true;\n    },\n    /**\n     * Rotate this Entity.\n     * @param {Number} deg Rotation angle (degree).\n     */\n    rotate: function(deg) {\n        this.rotation += deg;\n    },\n    /**\n     * Scaling factor on the x axis of this Entity.\n     * @type Number\n     */\n    scaleX: {\n        get: function() {\n            return this._scaleX;\n        },\n        set: function(scaleX) {\n            if(this._scaleX !== scaleX) {\n                this._scaleX = scaleX;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * Scaling factor on the y axis of this Entity.\n     * @type Number\n     */\n    scaleY: {\n        get: function() {\n            return this._scaleY;\n        },\n        set: function(scaleY) {\n            if(this._scaleY !== scaleY) {\n                this._scaleY = scaleY;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * Entity rotation angle (degree).\n     * @type Number\n     */\n    rotation: {\n        get: function() {\n            return this._rotation;\n        },\n        set: function(rotation) {\n            if(this._rotation !== rotation) {\n                this._rotation = rotation;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * The point of origin used for rotation and scaling.\n     * @type Number\n     */\n    originX: {\n        get: function() {\n            return this._originX;\n        },\n        set: function(originX) {\n            if(this._originX !== originX) {\n                this._originX = originX;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * The point of origin used for rotation and scaling.\n     * @type Number\n     */\n    originY: {\n        get: function() {\n            return this._originY;\n        },\n        set: function(originY) {\n            if(this._originY !== originY) {\n                this._originY = originY;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     */\n    enableCollection: function() {\n        this.addEventListener('addedtoscene', this._addSelfToCollection);\n        this.addEventListener('removedfromscene', this._removeSelfFromCollection);\n        if (this.scene) {\n            this._addSelfToCollection();\n        }\n    },\n    /**\n     */\n    disableCollection: function() {\n        this.removeEventListener('addedtoscene', this._addSelfToCollection);\n        this.removeEventListener('removedfromscene', this._removeSelfFromCollection);\n        if (this.scene) {\n            this._removeSelfFromCollection();\n        }\n    },\n    /**#nocode+*/\n    clearEventListener: function() {\n        _nodePrototypeClearEventListener.apply(this,arguments);\n        if (this.scene) {\n            this._removeSelfFromCollection();\n        }\n    },\n    /**#nocode-*/\n    _addSelfToCollection: function() {\n        if (this._isContainedInCollection) {\n            return;\n        }\n\n        var Constructor = this.getConstructor();\n        Constructor._collectionTarget.forEach(function(C) {\n            C.collection.push(this);\n        }, this);\n\n        this._isContainedInCollection = true;\n    },\n    _removeSelfFromCollection: function() {\n        if (!this._isContainedInCollection) {\n            return;\n        }\n\n        var Constructor = this.getConstructor();\n        Constructor._collectionTarget.forEach(function(C) {\n            var i = C.collection.indexOf(this);\n            if (i !== -1) {\n                C.collection.splice(i, 1);\n            }\n        }, this);\n\n        this._isContainedInCollection = false;\n    },\n    getBoundingRect: function() {\n        var w = this.width || 0;\n        var h = this.height || 0;\n        var mat = this._matrix;\n        var m11w = mat[0] * w, m12w = mat[1] * w,\n            m21h = mat[2] * h, m22h = mat[3] * h,\n            mdx = mat[4], mdy = mat[5];\n        var xw = [ mdx, m11w + mdx, m21h + mdx, m11w + m21h + mdx ].sort(function(a, b) { return a - b; });\n        var yh = [ mdy, m12w + mdy, m22h + mdy, m12w + m22h + mdy ].sort(function(a, b) { return a - b; });\n\n        return {\n            left: xw[0],\n            top: yh[0],\n            width: xw[3] - xw[0],\n            height: yh[3] - yh[0]\n        };\n    },\n    getOrientedBoundingRect: function() {\n        var w = this.width || 0;\n        var h = this.height || 0;\n        var mat = this._matrix;\n        var m11w = mat[0] * w, m12w = mat[1] * w,\n            m21h = mat[2] * h, m22h = mat[3] * h,\n            mdx = mat[4], mdy = mat[5];\n\n        return {\n            leftTop: [ mdx, mdy ],\n            rightTop: [ m11w + mdx, m12w + mdy ],\n            leftBottom: [ m21h + mdx, m22h + mdy ],\n            rightBottom: [ m11w + m21h + mdx, m12w + m22h + mdy ]\n        };\n    },\n    getConstructor: function() {\n        return Object.getPrototypeOf(this).constructor;\n    }\n});\n\nvar _collectizeConstructor = function(Constructor) {\n    if (Constructor._collective) {\n        return;\n    }\n    var rel = enchant.Class.getInheritanceTree(Constructor);\n    var i = rel.indexOf(enchant.Entity);\n    if (i !== -1) {\n        Constructor._collectionTarget = rel.splice(0, i + 1);\n    } else {\n        Constructor._collectionTarget = [];\n    }\n    Constructor.intersect = _staticIntersect;\n    Constructor.intersectStrict = _staticIntersectStrict;\n    Constructor.collection = [];\n    Constructor._collective = true;\n};\n\n_collectizeConstructor(enchant.Entity);\n\nenchant.Entity._inherited = function(subclass) {\n    _collectizeConstructor(subclass);\n};\n\n/**\n * @scope enchant.Sprite.prototype\n */\nenchant.Sprite = enchant.Class.create(enchant.Entity, {\n    /**\n     * @name enchant.Sprite\n     * @class\n     * Class which can display images.\n     * @param {Number} width Sprite width.\n     * @param {Number} height Sprite height.\n     *\n     * @example\n     * var bear = new Sprite(32, 32);\n     * bear.image = core.assets['chara1.gif'];\n     *\n     * @constructs\n     * @extends enchant.Entity\n     */\n    initialize: function(width, height) {\n        enchant.Entity.call(this);\n\n        this.width = width;\n        this.height = height;\n        this._image = null;\n        this._debugColor = '#ff0000';\n        this._frameLeft = 0;\n        this._frameTop = 0;\n        this._frame = 0;\n        this._frameSequence = null;\n    },\n    /**\n     * Image displayed in the Sprite.\n     * @type enchant.Surface\n     */\n    image: {\n        get: function() {\n            return this._image;\n        },\n        set: function(image) {\n            if (image === undefined) {\n                throw new Error('Assigned value on Sprite.image is undefined. Please double-check image path, and check if the image you want to use is preload before use.');\n            }\n            if (image === this._image) {\n                return;\n            }\n            this._image = image;\n            this._computeFramePosition();\n        }\n    },\n    /**\n     * Index of the frame to be displayed.\n     * Frames with the same width and height as Sprite will be arrayed from upper left corner of the \n     * {@link enchant.Sprite#image} image. When a sequence of numbers is provided, the displayed frame \n     * will switch automatically. At the end of the array the sequence will restart. By setting \n     * a value within the sequence to null, the frame switching is stopped.\n     *\n     * @example\n     * var sprite = new Sprite(32, 32);\n     * sprite.frame = [0, 1, 0, 2]\n     * //-> 0, 1, 0, 2, 0, 1, 0, 2,..\n     * sprite.frame = [0, 1, 0, 2, null]\n     * //-> 0, 1, 0, 2, (2, 2,.. :stop)\n     *\n     * @type Number|Array\n     */\n    frame: {\n        get: function() {\n            return this._frame;\n        },\n        set: function(frame) {\n            if (((this._frameSequence == null) && (this._frame === frame)) || (this._deepCompareToPreviousFrame(frame))) {\n                return;\n            }\n            if (frame instanceof Array) {\n                this._frameSequence = frame;\n            } else {\n                this._frameSequence = null;\n                this._frame = frame;\n                this._computeFramePosition();\n            }\n        }\n    },\n    _frameSequence: {\n        get: function() {\n            return this.__frameSequence;\n        },\n        set: function(frameSequence) {\n            if(frameSequence && !this.__frameSequence) {\n                this.addEventListener(enchant.Event.ENTER_FRAME, this._rotateFrameSequence);\n            } else if(!frameSequence && this.__frameSequence) {\n                this.removeEventListener(enchant.Event.ENTER_FRAME, this._rotateFrameSequence);\n            }\n            if(frameSequence) {\n                this.__frameSequence = frameSequence.slice();\n                this._originalFrameSequence = frameSequence.slice();\n                this._rotateFrameSequence();\n            } else {\n                this.__frameSequence = null;\n                this._originalFrameSequence = null;\n            }\n        }\n    },\n    /**\n     * If we are setting the same frame Array as animation,\n     * just continue animating.\n     * @private\n     */\n    _deepCompareToPreviousFrame: function(frameArray) {\n        if (frameArray === this._originalFrameSequence) {\n            return true;\n        }\n        if (frameArray == null || this._originalFrameSequence == null) {\n            return false;\n        }\n        if (!(frameArray instanceof Array)) {\n            return false;\n        }\n        if (frameArray.length !== this._originalFrameSequence.length) {\n            return false;\n        }\n        for (var i = 0; i < frameArray.length; ++i) {\n            if (frameArray[i] !== this._originalFrameSequence[i]){\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n     * 0 <= frame\n     * @private\n     */\n    _computeFramePosition: function() {\n        var image = this._image;\n        var row;\n        if (image != null) {\n            row = image.width / this._width | 0;\n            this._frameLeft = (this._frame % row | 0) * this._width;\n            this._frameTop = (this._frame / row | 0) * this._height % image.height;\n        }\n    },\n    _rotateFrameSequence: function() {\n        var frameSequence = this._frameSequence;\n        if (frameSequence && frameSequence.length !== 0) {\n            var nextFrame = frameSequence.shift();\n            if (nextFrame === null) {\n                this._frameSequence = null;\n                this.dispatchEvent(new enchant.Event(enchant.Event.ANIMATION_END));\n            } else {\n                this._frame = nextFrame;\n                this._computeFramePosition();\n                frameSequence.push(nextFrame);\n            }\n        }\n    },\n    /**#nocode+*/\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            this._width = width;\n            this._computeFramePosition();\n            this._dirty = true;\n        }\n    },\n    height: {\n        get: function() {\n            return this._height;\n        },\n        set: function(height) {\n            this._height = height;\n            this._computeFramePosition();\n            this._dirty = true;\n        }\n    },\n    /**#nocode-*/\n    cvsRender: function(ctx) {\n        var image = this._image,\n            w = this._width, h = this._height,\n            iw, ih, elem, sx, sy, sw, sh;\n        if (image && w !== 0 && h !== 0) {\n            iw = image.width;\n            ih = image.height;\n            if (iw < w || ih < h) {\n                ctx.fillStyle = enchant.Surface._getPattern(image);\n                ctx.fillRect(0, 0, w, h);\n            } else {\n                elem = image._element;\n                sx = this._frameLeft;\n                sy = Math.min(this._frameTop, ih - h);\n                // IE9 doesn't allow for negative or 0 widths/heights when drawing on the CANVAS element\n                sw = Math.max(0.01, Math.min(iw - sx, w));\n                sh = Math.max(0.01, Math.min(ih - sy, h));\n                ctx.drawImage(elem, sx, sy, sw, sh, 0, 0, w, h);\n            }\n        }\n    },\n    domRender: (function() {\n        if (enchant.ENV.VENDOR_PREFIX === 'ms') {\n            return function(element) {\n                if (this._image) {\n                    if (this._image._css) {\n                        this._style['background-image'] = this._image._css;\n                        this._style['background-position'] =\n                            -this._frameLeft + 'px ' +\n                            -this._frameTop + 'px';\n                    } else if (this._image._element) {\n                    }\n                }\n            };\n        } else {\n            return function(element) {\n                if (this._image) {\n                    if (this._image._css) {\n                        this._style['background-image'] = this._image._css;\n                        this._style['background-position'] =\n                            -this._frameLeft + 'px ' +\n                            -this._frameTop + 'px';\n                    } else if (this._image._element) {\n                    }\n                }\n            };\n        }\n    }())\n});\n\n/**\n * @scope enchant.Label.prototype\n */\nenchant.Label = enchant.Class.create(enchant.Entity, {\n    /**\n     * @name enchant.Label\n     * @class\n     * A class for Label object.\n     * @constructs\n     * @extends enchant.Entity\n     */\n    initialize: function(text) {\n        enchant.Entity.call(this);\n\n        this.text = text || '';\n        this.width = 300;\n        this.font = '14px serif';\n        this.textAlign = 'left';\n\n        this._debugColor = '#ff0000';\n    },\n    /**#nocode+*/\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            this._width = width;\n            this._dirty = true;\n            // issue #164\n            this.updateBoundArea();\n        }\n    },\n    /**#nocode-*/\n    /**\n     * Text to be displayed.\n     * @type String\n     */\n    text: {\n        get: function() {\n            return this._text;\n        },\n        set: function(text) {\n            text = '' + text;\n            if(this._text === text) {\n                return;\n            }\n            this._text = text;\n            text = text.replace(/<br ?\\/?>/gi, '<br/>');\n            this._splitText = text.split('<br/>');\n            this.updateBoundArea();\n            for (var i = 0, l = this._splitText.length; i < l; i++) {\n                text = this._splitText[i];\n                var metrics = this.getMetrics(text);\n                this._splitText[i] = {};\n                this._splitText[i].text = text;\n                this._splitText[i].height = metrics.height;\n                this._splitText[i].width = metrics.width;\n            }\n        }\n    },\n    /**\n     * Specifies horizontal alignment of text.\n     * Can be set according to the format of the CSS 'text-align' property.\n     * @type String\n     */\n    textAlign: {\n        get: function() {\n            return this._style['text-align'];\n        },\n        set: function(textAlign) {\n            this._style['text-align'] = textAlign;\n            this.updateBoundArea();\n        }\n    },\n    /**\n     * Font settings.\n     * Can be set according to the format of the CSS 'font' property.\n     * @type String\n     */\n    font: {\n        get: function() {\n            return this._style.font;\n        },\n        set: function(font) {\n            this._style.font = font;\n            this.updateBoundArea();\n        }\n    },\n    /**\n     * Text color settings.\n     * Can be set according to the format of the CSS 'color' property.\n     * @type String\n     */\n    color: {\n        get: function() {\n            return this._style.color;\n        },\n        set: function(color) {\n            this._style.color = color;\n        }\n    },\n    cvsRender: function(ctx) {\n        var x, y = 0;\n        var labelWidth = this.width;\n        var charWidth, amount, line, text, c, buf, increase, length;\n        var bufWidth;\n        if (this._splitText) {\n            ctx.textBaseline = 'top';\n            ctx.font = this.font;\n            ctx.fillStyle = this.color || '#000000';\n            charWidth = ctx.measureText(' ').width;\n            amount = labelWidth / charWidth;\n            for (var i = 0, l = this._splitText.length; i < l; i++) {\n                line = this._splitText[i];\n                text = line.text;\n                c = 0;\n                while (text.length > c + amount || ctx.measureText(text.slice(c, c + amount)).width > labelWidth) {\n                    buf = '';\n                    increase = amount;\n                    length = 0;\n                    while (increase > 0) {\n                        if (ctx.measureText(buf).width < labelWidth) {\n                            length += increase;\n                            buf = text.slice(c, c + length);\n                        } else {\n                            length -= increase;\n                            buf = text.slice(c, c + length);\n                        }\n                        increase = increase / 2 | 0;\n                    }\n                    ctx.fillText(buf, 0, y);\n                    y += line.height - 1;\n                    c += length;\n                }\n                buf = text.slice(c, c + text.length);\n                if (this.textAlign === 'right') {\n                    x = labelWidth - ctx.measureText(buf).width;\n                } else if (this.textAlign === 'center') {\n                    x = (labelWidth - ctx.measureText(buf).width) / 2;\n                } else {\n                    x = 0;\n                }\n                ctx.fillText(buf, x, y);\n                y += line.height - 1;\n            }\n        }\n    },\n    domRender: function(element) {\n        if (element.innerHTML !== this._text) {\n            element.innerHTML = this._text;\n        }\n    },\n    detectRender: function(ctx) {\n        ctx.fillRect(this._boundOffset, 0, this._boundWidth, this._boundHeight);\n    },\n    updateBoundArea: function() {\n        var metrics = this.getMetrics();\n        this._boundWidth = metrics.width;\n        this._boundHeight = metrics.height;\n        if (this.textAlign === 'right') {\n            this._boundOffset = this.width - this._boundWidth;\n        } else if (this.textAlign === 'center') {\n            this._boundOffset = (this.width - this._boundWidth) / 2;\n        } else {\n            this._boundOffset = 0;\n        }\n    },\n    getMetrics: function(text) {\n        var ret = {};\n        var div, width, height;\n        if (document.body) {\n            div = document.createElement('div');\n            for (var prop in this._style) {\n                if(prop !== 'width' && prop !== 'height') {\n                    div.style[prop] = this._style[prop];\n                }\n            }\n            text = text || this._text;\n            div.innerHTML = text.replace(/ /g, '&nbsp;');\n            div.style.whiteSpace = 'noWrap';\n            div.style.lineHeight = 1;\n            document.body.appendChild(div);\n            var computedStyle = getComputedStyle(div);\n            ret.height = parseInt(computedStyle.height, 10) + 1;\n            div.style.position = 'absolute';\n            ret.width = parseInt(computedStyle.width, 10) + 1;\n            document.body.removeChild(div);\n        } else {\n            ret.width = this.width;\n            ret.height = this.height;\n        }\n        return ret;\n    }\n});\n\n/**\n * @scope enchant.Map.prototype\n */\nenchant.Map = enchant.Class.create(enchant.Entity, {\n    /**\n     * @name enchant.Map\n     * @class\n     * A class to create and display maps from a tile set.\n     * @param {Number} tileWidth Tile width.\n     * @param {Number} tileHeight Tile height.\n     * @constructs\n     * @extends enchant.Entity\n     */\n    initialize: function(tileWidth, tileHeight) {\n        var core = enchant.Core.instance;\n\n        enchant.Entity.call(this);\n\n        var surface = new enchant.Surface(core.width, core.height);\n        this._surface = surface;\n        var canvas = surface._element;\n        canvas.style.position = 'absolute';\n        if (enchant.ENV.RETINA_DISPLAY && core.scale === 2) {\n            canvas.width = core.width * 2;\n            canvas.height = core.height * 2;\n            this._style.webkitTransformOrigin = '0 0';\n            this._style.webkitTransform = 'scale(0.5)';\n        } else {\n            canvas.width = core.width;\n            canvas.height = core.height;\n        }\n        this._context = canvas.getContext('2d');\n\n        this._tileWidth = tileWidth || 0;\n        this._tileHeight = tileHeight || 0;\n        this._image = null;\n        this._data = [\n            [\n                []\n            ]\n        ];\n        this._dirty = false;\n        this._tight = false;\n\n        this.touchEnabled = false;\n\n        /**\n         * Two dimensional array to store if collision detection should be performed for a tile.\n         * @type Number[][]\n         */\n        this.collisionData = null;\n\n        this._listeners['render'] = null;\n        this.addEventListener('render', function() {\n            if(this._dirty) {\n                this._previousOffsetX = this._previousOffsetY = null;\n            }\n        });\n    },\n    /**\n     * Set map data.\n     * Sets the tile data, whereas the data (two-dimensional array with indizes starting from 0) \n     * is mapped on the image starting from the upper left corner.\n     * When more than one map data array is set, they are displayed in reverse order.\n     * @param {...Number[][]} data Two-dimensional array of tile indizes. Multiple designations possible.\n     */\n    loadData: function(data) {\n        this._data = Array.prototype.slice.apply(arguments);\n        this._dirty = true;\n\n        this._tight = false;\n        for (var i = 0, len = this._data.length; i < len; i++) {\n            var c = 0;\n            data = this._data[i];\n            for (var y = 0, l = data.length; y < l; y++) {\n                for (var x = 0, ll = data[y].length; x < ll; x++) {\n                    if (data[y][x] >= 0) {\n                        c++;\n                    }\n                }\n            }\n            if (c / (data.length * data[0].length) > 0.2) {\n                this._tight = true;\n                break;\n            }\n        }\n    },\n    /**\n     * Checks what tile is present at the given position.\n     * @param {Number} x x coordinates of the point on the map.\n     * @param {Number} y y coordinates of the point on the map.\n     * @return {*} The tile data for the given position.\n     */\n    checkTile: function(x, y) {\n        if (x < 0 || this.width <= x || y < 0 || this.height <= y) {\n            return false;\n        }\n        var width = this._image.width;\n        var height = this._image.height;\n        var tileWidth = this._tileWidth || width;\n        var tileHeight = this._tileHeight || height;\n        x = x / tileWidth | 0;\n        y = y / tileHeight | 0;\n        //\t\treturn this._data[y][x];\n        var data = this._data[0];\n        return data[y][x];\n    },\n    /**\n     * Judges whether or not obstacles are on top of Map.\n     * @param {Number} x x coordinates of detection spot on map.\n     * @param {Number} y y coordinates of detection spot on map.\n     * @return {Boolean} True, if there are obstacles.\n     */\n    hitTest: function(x, y) {\n        if (x < 0 || this.width <= x || y < 0 || this.height <= y) {\n            return false;\n        }\n        var width = this._image.width;\n        var height = this._image.height;\n        var tileWidth = this._tileWidth || width;\n        var tileHeight = this._tileHeight || height;\n        x = x / tileWidth | 0;\n        y = y / tileHeight | 0;\n        if (this.collisionData != null) {\n            return this.collisionData[y] && !!this.collisionData[y][x];\n        } else {\n            for (var i = 0, len = this._data.length; i < len; i++) {\n                var data = this._data[i];\n                var n;\n                if (data[y] != null && (n = data[y][x]) != null &&\n                    0 <= n && n < (width / tileWidth | 0) * (height / tileHeight | 0)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n    /**\n     * Image with which the tile set is displayed on the map.\n     * @type enchant.Surface\n     */\n    image: {\n        get: function() {\n            return this._image;\n        },\n        set: function(image) {\n            var core = enchant.Core.instance;\n\n            this._image = image;\n            if (enchant.ENV.RETINA_DISPLAY && core.scale === 2) {\n                var img = new enchant.Surface(image.width * 2, image.height * 2);\n                var tileWidth = this._tileWidth || image.width;\n                var tileHeight = this._tileHeight || image.height;\n                var row = image.width / tileWidth | 0;\n                var col = image.height / tileHeight | 0;\n                for (var y = 0; y < col; y++) {\n                    for (var x = 0; x < row; x++) {\n                        img.draw(image, x * tileWidth, y * tileHeight, tileWidth, tileHeight,\n                            x * tileWidth * 2, y * tileHeight * 2, tileWidth * 2, tileHeight * 2);\n                    }\n                }\n                this._doubledImage = img;\n            }\n            this._dirty = true;\n        }\n    },\n    /**\n     * Map tile width.\n     * @type Number\n     */\n    tileWidth: {\n        get: function() {\n            return this._tileWidth;\n        },\n        set: function(tileWidth) {\n            if(this._tileWidth !== tileWidth) {\n                this._tileWidth = tileWidth;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * Map tile height.\n     * @type Number\n     */\n    tileHeight: {\n        get: function() {\n            return this._tileHeight;\n        },\n        set: function(tileHeight) {\n            if(this._tileHeight !== tileHeight) {\n                this._tileHeight = tileHeight;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n     * @private\n     */\n    width: {\n        get: function() {\n            return this._tileWidth * this._data[0][0].length;\n        }\n    },\n    /**\n     * @private\n     */\n    height: {\n        get: function() {\n            return this._tileHeight * this._data[0].length;\n        }\n    },\n    /**\n     * @private\n     */\n    redraw: function(x, y, width, height) {\n        if (this._image == null) {\n            return;\n        }\n\n        var image, tileWidth, tileHeight, dx, dy;\n        if (this._doubledImage) {\n            image = this._doubledImage;\n            tileWidth = this._tileWidth * 2;\n            tileHeight = this._tileHeight * 2;\n            dx = -this._offsetX * 2;\n            dy = -this._offsetY * 2;\n            x *= 2;\n            y *= 2;\n            width *= 2;\n            height *= 2;\n        } else {\n            image = this._image;\n            tileWidth = this._tileWidth;\n            tileHeight = this._tileHeight;\n            dx = -this._offsetX;\n            dy = -this._offsetY;\n        }\n        var row = image.width / tileWidth | 0;\n        var col = image.height / tileHeight | 0;\n        var left = Math.max((x + dx) / tileWidth | 0, 0);\n        var top = Math.max((y + dy) / tileHeight | 0, 0);\n        var right = Math.ceil((x + dx + width) / tileWidth);\n        var bottom = Math.ceil((y + dy + height) / tileHeight);\n\n        var source = image._element;\n        var context = this._context;\n        var canvas = context.canvas;\n        context.clearRect(x, y, width, height);\n        for (var i = 0, len = this._data.length; i < len; i++) {\n            var data = this._data[i];\n            var r = Math.min(right, data[0].length);\n            var b = Math.min(bottom, data.length);\n            for (y = top; y < b; y++) {\n                for (x = left; x < r; x++) {\n                    var n = data[y][x];\n                    if (0 <= n && n < row * col) {\n                        var sx = (n % row) * tileWidth;\n                        var sy = (n / row | 0) * tileHeight;\n                        context.drawImage(source, sx, sy, tileWidth, tileHeight,\n                            x * tileWidth - dx, y * tileHeight - dy, tileWidth, tileHeight);\n                    }\n                }\n            }\n        }\n    },\n    /**\n     * @private\n     */\n    updateBuffer: function() {\n        if (this._visible === undefined || this._visible) {\n            var core = enchant.Core.instance;\n            if (this._dirty || this._previousOffsetX == null) {\n                this.redraw(0, 0, core.width, core.height);\n            } else if (this._offsetX !== this._previousOffsetX ||\n                    this._offsetY !== this._previousOffsetY) {\n                if (this._tight) {\n                    var x = -this._offsetX;\n                    var y = -this._offsetY;\n                    var px = -this._previousOffsetX;\n                    var py = -this._previousOffsetY;\n                    var w1 = x - px + core.width;\n                    var w2 = px - x + core.width;\n                    var h1 = y - py + core.height;\n                    var h2 = py - y + core.height;\n                    if (w1 > this._tileWidth && w2 > this._tileWidth &&\n                            h1 > this._tileHeight && h2 > this._tileHeight) {\n                        var sx, sy, dx, dy, sw, sh;\n                        if (w1 < w2) {\n                            sx = 0;\n                            dx = px - x;\n                            sw = w1;\n                        } else {\n                            sx = x - px;\n                            dx = 0;\n                            sw = w2;\n                        }\n                        if (h1 < h2) {\n                            sy = 0;\n                            dy = py - y;\n                            sh = h1;\n                        } else {\n                            sy = y - py;\n                            dy = 0;\n                            sh = h2;\n                        }\n\n                        if (core._buffer == null) {\n                            core._buffer = document.createElement('canvas');\n                            core._buffer.width = this._context.canvas.width;\n                            core._buffer.height = this._context.canvas.height;\n                        }\n                        var context = core._buffer.getContext('2d');\n                        if (this._doubledImage) {\n                            context.clearRect(0, 0, sw * 2, sh * 2);\n                            context.drawImage(this._context.canvas,\n                                    sx * 2, sy * 2, sw * 2, sh * 2, 0, 0, sw * 2, sh * 2);\n                            context = this._context;\n                            context.clearRect(dx * 2, dy * 2, sw * 2, sh * 2);\n                            context.drawImage(core._buffer,\n                                    0, 0, sw * 2, sh * 2, dx * 2, dy * 2, sw * 2, sh * 2);\n                        } else {\n                            context.clearRect(0, 0, sw, sh);\n                            context.drawImage(this._context.canvas,\n                                    sx, sy, sw, sh, 0, 0, sw, sh);\n                            context = this._context;\n                            context.clearRect(dx, dy, sw, sh);\n                            context.drawImage(core._buffer,\n                                    0, 0, sw, sh, dx, dy, sw, sh);\n                        }\n\n                        if (dx === 0) {\n                            this.redraw(sw, 0, core.width - sw, core.height);\n                        } else {\n                            this.redraw(0, 0, core.width - sw, core.height);\n                        }\n                        if (dy === 0) {\n                            this.redraw(0, sh, core.width, core.height - sh);\n                        } else {\n                            this.redraw(0, 0, core.width, core.height - sh);\n                        }\n                    } else {\n                        this.redraw(0, 0, core.width, core.height);\n                    }\n                } else {\n                    this.redraw(0, 0, core.width, core.height);\n                }\n            }\n            this._previousOffsetX = this._offsetX;\n            this._previousOffsetY = this._offsetY;\n        }\n    },\n    cvsRender: function(ctx) {\n        if (this.width !== 0 && this.height !== 0) {\n            var core = enchant.Core.instance;\n            this.updateBuffer();\n            ctx.save();\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            var cvs = this._context.canvas;\n                ctx.drawImage(cvs, 0, 0, core.width, core.height);\n            ctx.restore();\n        }\n    },\n    domRender: function(element) {\n        if (this._image) {\n            this.updateBuffer();\n            this._style['background-image'] = this._surface._css;\n            // bad performance\n            this._style[enchant.ENV.VENDOR_PREFIX + 'Transform'] = 'matrix(1, 0, 0, 1, 0, 0)';\n        }\n    }\n});\n\n\n/**\n * @scope enchant.Group.prototype\n */\nenchant.Group = enchant.Class.create(enchant.Node, {\n    /**\n     * @name enchant.Group\n     * @class\n     * A class that can hold multiple {@link enchant.Node}.\n     *\n     * @example\n     * var stage = new Group();\n     * stage.addChild(player);\n     * stage.addChild(enemy);\n     * stage.addChild(map);\n     * stage.addEventListener('enterframe', function() {\n     *     // Moves the entire frame in according to the player's coordinates.\n     *     if (this.x > 64 - player.x) {\n     *         this.x = 64 - player.x;\n     *     }\n     * });\n     * @constructs\n     * @extends enchant.Node\n     */\n    initialize: function() {\n        /**\n         * Child Nodes.\n         * @type enchant.Node[]\n         */\n        this.childNodes = [];\n\n        enchant.Node.call(this);\n\n        this._rotation = 0;\n        this._scaleX = 1;\n        this._scaleY = 1;\n\n        this._originX = null;\n        this._originY = null;\n\n        this.__dirty = false;\n\n        [enchant.Event.ADDED_TO_SCENE, enchant.Event.REMOVED_FROM_SCENE]\n            .forEach(function(event) {\n                this.addEventListener(event, function(e) {\n                    this.childNodes.forEach(function(child) {\n                        child.scene = this.scene;\n                        child.dispatchEvent(e);\n                    }, this);\n                });\n            }, this);\n    },\n    /**\n     * Adds a Node to the Group.\n     * @param {enchant.Node} node Node to be added.\n     */\n    addChild: function(node) {\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n        this.childNodes.push(node);\n        node.parentNode = this;\n        var childAdded = new enchant.Event('childadded');\n        childAdded.node = node;\n        childAdded.next = null;\n        this.dispatchEvent(childAdded);\n        node.dispatchEvent(new enchant.Event('added'));\n        if (this.scene) {\n            node.scene = this.scene;\n            var addedToScene = new enchant.Event('addedtoscene');\n            node.dispatchEvent(addedToScene);\n        }\n    },\n    /**\n     * Incorporates Node into Group.\n     * @param {enchant.Node} node Node to be incorporated.\n     * @param {enchant.Node} reference Node in position before insertion.\n     */\n    insertBefore: function(node, reference) {\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n        var i = this.childNodes.indexOf(reference);\n        if (i !== -1) {\n            this.childNodes.splice(i, 0, node);\n            node.parentNode = this;\n            var childAdded = new enchant.Event('childadded');\n            childAdded.node = node;\n            childAdded.next = reference;\n            this.dispatchEvent(childAdded);\n            node.dispatchEvent(new enchant.Event('added'));\n            if (this.scene) {\n                node.scene = this.scene;\n                var addedToScene = new enchant.Event('addedtoscene');\n                node.dispatchEvent(addedToScene);\n            }\n        } else {\n            this.addChild(node);\n        }\n    },\n    /**\n     * Remove a Node from the Group.\n     * @param {enchant.Node} node Node to be deleted.\n     */\n    removeChild: function(node) {\n        var i;\n        if ((i = this.childNodes.indexOf(node)) !== -1) {\n            this.childNodes.splice(i, 1);\n            node.parentNode = null;\n            var childRemoved = new enchant.Event('childremoved');\n            childRemoved.node = node;\n            this.dispatchEvent(childRemoved);\n            node.dispatchEvent(new enchant.Event('removed'));\n            if (this.scene) {\n                node.scene = null;\n                var removedFromScene = new enchant.Event('removedfromscene');\n                node.dispatchEvent(removedFromScene);\n            }\n        }\n    },\n    /**\n     * The Node which is the first child.\n     * @type enchant.Node\n     */\n    firstChild: {\n        get: function() {\n            return this.childNodes[0];\n        }\n    },\n    /**\n     * The Node which is the last child.\n     * @type enchant.Node\n     */\n    lastChild: {\n        get: function() {\n            return this.childNodes[this.childNodes.length - 1];\n        }\n    },\n    /**\n    * Group rotation angle (degree).\n    * @type Number\n    */\n    rotation: {\n        get: function() {\n            return this._rotation;\n        },\n        set: function(rotation) {\n            if(this._rotation !== rotation) {\n                this._rotation = rotation;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n    * Scaling factor on the x axis of the Group.\n    * @type Number\n    * @see enchant.Group#originX\n    * @see enchant.Group#originY\n    */\n    scaleX: {\n        get: function() {\n            return this._scaleX;\n        },\n        set: function(scale) {\n            if(this._scaleX !== scale) {\n                this._scaleX = scale;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n    * Scaling factor on the y axis of the Group.\n    * @type Number\n    * @see enchant.Group#originX\n    * @see enchant.Group#originY\n    */\n    scaleY: {\n        get: function() {\n            return this._scaleY;\n        },\n        set: function(scale) {\n            if(this._scaleY !== scale) {\n                this._scaleY = scale;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n    * origin point of rotation, scaling\n    * @type Number\n    */\n    originX: {\n        get: function() {\n            return this._originX;\n        },\n        set: function(originX) {\n            if(this._originX !== originX) {\n                this._originX = originX;\n                this._dirty = true;\n            }\n        }\n    },\n    /**\n    * origin point of rotation, scaling\n    * @type Number\n    */\n    originY: {\n        get: function() {\n            return this._originY;\n        },\n        set: function(originY) {\n            if(this._originY !== originY) {\n                this._originY = originY;\n                this._dirty = true;\n            }\n        }\n    },\n    /**#nocode+*/\n    _dirty: {\n        get: function() {\n            return this.__dirty;\n        },\n        set: function(dirty) {\n            dirty = !!dirty;\n            this.__dirty = dirty;\n            if (dirty) {\n                for (var i = 0, l = this.childNodes.length; i < l; i++) {\n                    this.childNodes[i]._dirty = true;\n                }\n            }\n        }\n    }\n    /**#nocode-*/\n});\n\nenchant.Matrix = enchant.Class.create({\n    initialize: function() {\n        this.reset();\n    },\n    reset: function() {\n        this.stack = [];\n        this.stack.push([ 1, 0, 0, 1, 0, 0 ]);\n    },\n    makeTransformMatrix: function(node, dest) {\n        var x = node._x;\n        var y = node._y;\n        var width = node.width || 0;\n        var height = node.height || 0;\n        var rotation = node._rotation || 0;\n        var scaleX = (typeof node._scaleX === 'number') ? node._scaleX : 1;\n        var scaleY = (typeof node._scaleY === 'number') ? node._scaleY : 1;\n        var theta = rotation * Math.PI / 180;\n        var tmpcos = Math.cos(theta);\n        var tmpsin = Math.sin(theta);\n        var w = (typeof node._originX === 'number') ? node._originX : width / 2;\n        var h = (typeof node._originY === 'number') ? node._originY : height / 2;\n        var a = scaleX * tmpcos;\n        var b = scaleX * tmpsin;\n        var c = scaleY * tmpsin;\n        var d = scaleY * tmpcos;\n        dest[0] = a;\n        dest[1] = b;\n        dest[2] = -c;\n        dest[3] = d;\n        dest[4] = (-a * w + c * h + x + w);\n        dest[5] = (-b * w - d * h + y + h);\n    },\n    multiply: function(m1, m2, dest) {\n        var a11 = m1[0], a21 = m1[2], adx = m1[4],\n            a12 = m1[1], a22 = m1[3], ady = m1[5];\n        var b11 = m2[0], b21 = m2[2], bdx = m2[4],\n            b12 = m2[1], b22 = m2[3], bdy = m2[5];\n\n        dest[0] = a11 * b11 + a21 * b12;\n        dest[1] = a12 * b11 + a22 * b12;\n        dest[2] = a11 * b21 + a21 * b22;\n        dest[3] = a12 * b21 + a22 * b22;\n        dest[4] = a11 * bdx + a21 * bdy + adx;\n        dest[5] = a12 * bdx + a22 * bdy + ady;\n    },\n    multiplyVec: function(mat, vec, dest) {\n        var x = vec[0], y = vec[1];\n        var m11 = mat[0], m21 = mat[2], mdx = mat[4],\n            m12 = mat[1], m22 = mat[3], mdy = mat[5];\n        dest[0] = m11 * x + m21 * y + mdx;\n        dest[1] = m12 * x + m22 * y + mdy;\n    }\n});\nenchant.Matrix.instance = new enchant.Matrix();\n\nenchant.DetectColorManager = enchant.Class.create({\n    initialize: function(reso, max) {\n        this.reference = [];\n        this.colorResolution = reso || 16;\n        this.max = max || 1;\n        this.capacity = Math.pow(this.colorResolution, 3);\n        for (var i = 1, l = this.capacity; i < l; i++) {\n            this.reference[i] = null;\n        }\n    },\n    attachDetectColor: function(sprite) {\n        var i = this.reference.indexOf(null);\n        if (i === -1) {\n            i = 1;\n        }\n        this.reference[i] = sprite;\n        return this._getColor(i);\n    },\n    detachDetectColor: function(sprite) {\n        var i = this.reference.indexOf(sprite);\n        if (i !== -1) {\n            this.reference[i] = null;\n        }\n    },\n    _getColor: function(n) {\n        var C = this.colorResolution;\n        var d = C / this.max;\n        return [\n            parseInt((n / C / C) % C, 10) / d,\n            parseInt((n / C) % C, 10) / d,\n            parseInt(n % C, 10) / d,\n            1.0\n        ];\n    },\n    _decodeDetectColor: function(color, i) {\n        i = i || 0;\n        var C = this.colorResolution;\n        return ~~(color[i] * C * C * C / 256) +\n            ~~(color[i + 1] * C * C / 256) +\n            ~~(color[i + 2] * C / 256);\n    },\n    getSpriteByColor: function(color) {\n        return this.reference[this._decodeDetectColor(color)];\n    },\n    getSpriteByColors: function(rgba) {\n        var i, l, id, result,\n            score = 0,\n            found = {};\n\n        for (i = 0, l = rgba.length; i < l; i+= 4) {\n            id = this._decodeDetectColor(rgba, i);\n            found[id] = (found[id] || 0) + 1;\n        }\n        for (id in found) {\n            if (found[id] > score) {\n                score = found[id];\n                result = id;\n            }\n        }\n\n        return this.reference[result];\n    }\n});\n\nenchant.DomManager = enchant.Class.create({\n    initialize: function(node, elementDefinition) {\n        var core = enchant.Core.instance;\n        this.layer = null;\n        this.targetNode = node;\n        if (typeof elementDefinition === 'string') {\n            this.element = document.createElement(elementDefinition);\n        } else if (elementDefinition instanceof HTMLElement) {\n            this.element = elementDefinition;\n        }\n        this.style = this.element.style;\n        this.style.position = 'absolute';\n        this.style[enchant.ENV.VENDOR_PREFIX + 'TransformOrigin'] = '0px 0px';\n        if (core._debug) {\n            this.style.border = '1px solid blue';\n            this.style.margin = '-1px';\n        }\n\n        var manager = this;\n        this._setDomTarget = function() {\n            manager.layer._touchEventTarget = manager.targetNode;\n        };\n        this._attachEvent();\n    },\n    getDomElement: function() {\n        return this.element;\n    },\n    getDomElementAsNext: function() {\n        return this.element;\n    },\n    getNextManager: function(manager) {\n        var i = this.targetNode.parentNode.childNodes.indexOf(manager.targetNode);\n        if (i !== this.targetNode.parentNode.childNodes.length - 1) {\n            return this.targetNode.parentNode.childNodes[i + 1]._domManager;\n        } else {\n            return null;\n        }\n    },\n    addManager: function(childManager, nextManager) {\n        var nextElement;\n        if (nextManager) {\n            nextElement = nextManager.getDomElementAsNext();\n        }\n        var element = childManager.getDomElement();\n        if (element instanceof Array) {\n            element.forEach(function(child) {\n                if (nextElement) {\n                    this.element.insertBefore(child, nextElement);\n                } else {\n                    this.element.appendChild(child);\n                }\n            }, this);\n        } else {\n            if (nextElement) {\n                this.element.insertBefore(element, nextElement);\n            } else {\n                this.element.appendChild(element);\n            }\n        }\n        this.setLayer(this.layer);\n    },\n    removeManager: function(childManager) {\n        if (childManager instanceof enchant.DomlessManager) {\n            childManager._domRef.forEach(function(element) {\n                this.element.removeChild(element);\n            }, this);\n        } else {\n            this.element.removeChild(childManager.element);\n        }\n        this.setLayer(this.layer);\n    },\n    setLayer: function(layer) {\n        this.layer = layer;\n        var node = this.targetNode;\n        var manager;\n        if (node.childNodes) {\n            for (var i = 0, l = node.childNodes.length; i < l; i++) {\n                manager = node.childNodes[i]._domManager;\n                if (manager) {\n                    manager.setLayer(layer);\n                }\n            }\n        }\n    },\n    render: function(inheritMat) {\n        var node = this.targetNode;\n        var matrix = enchant.Matrix.instance;\n        var stack = matrix.stack;\n        var dest = [];\n        matrix.makeTransformMatrix(node, dest);\n        matrix.multiply(stack[stack.length - 1], dest, dest);\n        matrix.multiply(inheritMat, dest, inheritMat);\n        node._matrix = inheritMat;\n        var ox = (typeof node._originX === 'number') ? node._originX : node.width / 2 || 0;\n        var oy = (typeof node._originY === 'number') ? node._originY : node.height / 2 || 0;\n        var vec = [ ox, oy ];\n        matrix.multiplyVec(dest, vec, vec);\n\n        node._offsetX = vec[0] - ox;\n        node._offsetY = vec[1] - oy;\n        if(node.parentNode && !(node.parentNode instanceof enchant.Group)) {\n            node._offsetX += node.parentNode._offsetX;\n            node._offsetY += node.parentNode._offsetY;\n        }\n        if (node._dirty) {\n            this.style[enchant.ENV.VENDOR_PREFIX + 'Transform'] = 'matrix(' +\n                dest[0].toFixed(10) + ',' +\n                dest[1].toFixed(10) + ',' +\n                dest[2].toFixed(10) + ',' +\n                dest[3].toFixed(10) + ',' +\n                dest[4].toFixed(10) + ',' +\n                dest[5].toFixed(10) +\n            ')';\n        }\n        this.domRender();\n    },\n    domRender: function() {\n        var node = this.targetNode;\n        if(!node._style) {\n            node._style = {};\n        }\n        if(!node.__styleStatus) {\n            node.__styleStatus = {};\n        }\n        if (node.width !== null) {\n            node._style.width = node.width + 'px';\n        }\n        if (node.height !== null) {\n            node._style.height = node.height + 'px';\n        }\n        node._style.opacity = node._opacity;\n        node._style['background-color'] = node._backgroundColor;\n        if (typeof node._visible !== 'undefined') {\n            node._style.display = node._visible ? 'block' : 'none';\n        }\n        if (typeof node.domRender === 'function') {\n            node.domRender(this.element);\n        }\n        var value;\n        for (var prop in node._style) {\n            value = node._style[prop];\n            if(node.__styleStatus[prop] !== value && value != null) {\n                this.style.setProperty(prop, '' + value);\n                node.__styleStatus[prop] = value;\n            }\n        }\n    },\n    _attachEvent: function() {\n        if (enchant.ENV.TOUCH_ENABLED) {\n            this.element.addEventListener('touchstart', this._setDomTarget, true);\n        }\n        this.element.addEventListener('mousedown', this._setDomTarget, true);\n    },\n    _detachEvent: function() {\n        if (enchant.ENV.TOUCH_ENABLED) {\n            this.element.removeEventListener('touchstart', this._setDomTarget, true);\n        }\n        this.element.removeEventListener('mousedown', this._setDomTarget, true);\n    },\n    remove: function() {\n        this._detachEvent();\n        this.element = this.style = this.targetNode = null;\n    }\n});\n\nenchant.DomlessManager = enchant.Class.create({\n    initialize: function(node) {\n        this._domRef = [];\n        this.targetNode = node;\n    },\n    _register: function(element, nextElement) {\n        var i = this._domRef.indexOf(nextElement);\n        if (element instanceof Array) {\n            if (i === -1) {\n                Array.prototype.push.apply(this._domRef, element);\n            } else {\n                Array.prototype.splice.apply(this._domRef, [i, 0].concat(element));\n            }\n        } else {\n            if (i === -1) {\n                this._domRef.push(element);\n            } else {\n                this._domRef.splice(i, 0, element);\n            }\n        }\n    },\n    getNextManager: function(manager) {\n        var i = this.targetNode.parentNode.childNodes.indexOf(manager.targetNode);\n        if (i !== this.targetNode.parentNode.childNodes.length - 1) {\n            return this.targetNode.parentNode.childNodes[i + 1]._domManager;\n        } else {\n            return null;\n        }\n    },\n    getDomElement: function() {\n        var ret = [];\n        this.targetNode.childNodes.forEach(function(child) {\n            ret = ret.concat(child._domManager.getDomElement());\n        });\n        return ret;\n    },\n    getDomElementAsNext: function() {\n        if (this._domRef.length) {\n            return this._domRef[0];\n        } else {\n            var nextManager = this.getNextManager(this);\n            if (nextManager) {\n                return nextManager.element;\n            } else {\n                return null;\n            }\n        }\n    },\n    addManager: function(childManager, nextManager) {\n        var parentNode = this.targetNode.parentNode;\n        if (parentNode) {\n            if (nextManager === null) {\n                nextManager = this.getNextManager(this);\n            }\n            if (parentNode instanceof enchant.Scene) {\n                parentNode._layers.Dom._domManager.addManager(childManager, nextManager);\n            } else {\n                parentNode._domManager.addManager(childManager, nextManager);\n            }\n        }\n        var nextElement = nextManager ? nextManager.getDomElementAsNext() : null;\n        this._register(childManager.getDomElement(), nextElement);\n        this.setLayer(this.layer);\n    },\n    removeManager: function(childManager) {\n        var dom;\n        var i = this._domRef.indexOf(childManager.element);\n        if (i !== -1) {\n            dom = this._domRef[i];\n            dom.parentNode.removeChild(dom);\n            this._domRef.splice(i, 1);\n        }\n        this.setLayer(this.layer);\n    },\n    setLayer: function(layer) {\n        this.layer = layer;\n        var node = this.targetNode;\n        var manager;\n        if (node.childNodes) {\n            for (var i = 0, l = node.childNodes.length; i < l; i++) {\n                manager = node.childNodes[i]._domManager;\n                if (manager) {\n                    manager.setLayer(layer);\n                }\n            }\n        }\n    },\n    render: function(inheritMat) {\n        var matrix = enchant.Matrix.instance;\n        var stack = matrix.stack;\n        var node = this.targetNode;\n        var dest = [];\n        matrix.makeTransformMatrix(node, dest);\n        matrix.multiply(stack[stack.length - 1], dest, dest);\n        matrix.multiply(inheritMat, dest, inheritMat);\n        node._matrix = inheritMat;\n        var ox = (typeof node._originX === 'number') ? node._originX : node.width / 2 || 0;\n        var oy = (typeof node._originY === 'number') ? node._originY : node.height / 2 || 0;\n        var vec = [ ox, oy ];\n        matrix.multiplyVec(dest, vec, vec);\n        node._offsetX = vec[0] - ox;\n        node._offsetY = vec[1] - oy;\n        stack.push(dest);\n    },\n    remove: function() {\n        this._domRef = [];\n        this.targetNode = null;\n    }\n});\n\nenchant.DomLayer = enchant.Class.create(enchant.Group, {\n    initialize: function() {\n        var core = enchant.Core.instance;\n        enchant.Group.call(this);\n\n        this._touchEventTarget = null;\n\n        this._element = document.createElement('div');\n        this._element.style.position = 'absolute';\n\n        this._domManager = new enchant.DomManager(this, this._element);\n        this._domManager.layer = this;\n\n        this.width = core.width;\n        this.height = core.height;\n\n        var touch = [\n            enchant.Event.TOUCH_START,\n            enchant.Event.TOUCH_MOVE,\n            enchant.Event.TOUCH_END\n        ];\n\n        touch.forEach(function(type) {\n            this.addEventListener(type, function(e) {\n                if (this._scene) {\n                    this._scene.dispatchEvent(e);\n                }\n            });\n        }, this);\n\n        var __onchildadded = function(e) {\n            var child = e.node;\n            var next = e.next;\n            var self = e.target;\n            var nextManager = next ? next._domManager : null;\n            enchant.DomLayer._attachDomManager(child, __onchildadded, __onchildremoved);\n            self._domManager.addManager(child._domManager, nextManager);\n            var render = new enchant.Event(enchant.Event.RENDER);\n            child._dirty = true;\n            self._domManager.layer._rendering(child, render);\n        };\n\n        var __onchildremoved = function(e) {\n            var child = e.node;\n            var self = e.target;\n            self._domManager.removeManager(child._domManager);\n            enchant.DomLayer._detachDomManager(child, __onchildadded, __onchildremoved);\n        };\n\n        this.addEventListener('childremoved', __onchildremoved);\n        this.addEventListener('childadded', __onchildadded);\n\n    },\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            this._width = width;\n            this._element.style.width = width + 'px';\n        }\n    },\n    height: {\n        get: function() {\n            return this._height;\n        },\n        set: function(height) {\n            this._height = height;\n            this._element.style.height = height + 'px';\n        }\n    },\n    addChild: function(node) {\n        this.childNodes.push(node);\n        node.parentNode = this;\n        var childAdded = new enchant.Event('childadded');\n        childAdded.node = node;\n        childAdded.next = null;\n        this.dispatchEvent(childAdded);\n        node.dispatchEvent(new enchant.Event('added'));\n        if (this.scene) {\n            node.scene = this.scene;\n            var addedToScene = new enchant.Event('addedtoscene');\n            node.dispatchEvent(addedToScene);\n        }\n    },\n    insertBefore: function(node, reference) {\n        var i = this.childNodes.indexOf(reference);\n        if (i !== -1) {\n            this.childNodes.splice(i, 0, node);\n            node.parentNode = this;\n            var childAdded = new enchant.Event('childadded');\n            childAdded.node = node;\n            childAdded.next = reference;\n            this.dispatchEvent(childAdded);\n            node.dispatchEvent(new enchant.Event('added'));\n            if (this.scene) {\n                node.scene = this.scene;\n                var addedToScene = new enchant.Event('addedtoscene');\n                node.dispatchEvent(addedToScene);\n            }\n        } else {\n            this.addChild(node);\n        }\n    },\n    _startRendering: function() {\n        this.addEventListener('exitframe', this._onexitframe);\n        this._onexitframe();\n    },\n    _stopRendering: function() {\n        this.removeEventListener('exitframe', this._onexitframe);\n        this._onexitframe();\n    },\n    _onexitframe: function() {\n        this._rendering(this, new enchant.Event(enchant.Event.RENDER));\n    },\n    _rendering: function(node, e, inheritMat) {\n        var child;\n        if (!inheritMat) {\n            inheritMat = [ 1, 0, 0, 1, 0, 0 ];\n        }\n        node.dispatchEvent(e);\n        node._domManager.render(inheritMat);\n        if (node.childNodes) {\n            for (var i = 0, l = node.childNodes.length; i < l; i++) {\n                child = node.childNodes[i];\n                this._rendering(child, e, inheritMat.slice());\n            }\n        }\n        if (node._domManager instanceof enchant.DomlessManager) {\n            enchant.Matrix.instance.stack.pop();\n        }\n        node._dirty = false;\n    },\n    _determineEventTarget: function() {\n        var target = this._touchEventTarget;\n        this._touchEventTarget = null;\n        return (target === this) ? null : target;\n    }\n});\n\nenchant.DomLayer._attachDomManager = function(node, onchildadded, onchildremoved) {\n    var child;\n    if (!node._domManager) {\n        node.addEventListener('childadded', onchildadded);\n        node.addEventListener('childremoved', onchildremoved);\n        if (node instanceof enchant.Group) {\n            node._domManager = new enchant.DomlessManager(node);\n        } else {\n            if (node._element) {\n                node._domManager = new enchant.DomManager(node, node._element);\n            } else {\n                node._domManager = new enchant.DomManager(node, 'div');\n            }\n        }\n    }\n    if (node.childNodes) {\n        for (var i = 0, l = node.childNodes.length; i < l; i++) {\n            child = node.childNodes[i];\n            enchant.DomLayer._attachDomManager(child, onchildadded, onchildremoved);\n            node._domManager.addManager(child._domManager, null);\n        }\n    }\n};\n\nenchant.DomLayer._detachDomManager = function(node, onchildadded, onchildremoved) {\n    var child;\n    node.removeEventListener('childadded', onchildadded);\n    node.removeEventListener('childremoved', onchildremoved);\n    if (node.childNodes) {\n        for (var i = 0, l = node.childNodes.length; i < l; i++) {\n            child = node.childNodes[i];\n            node._domManager.removeManager(child._domManager, null);\n            enchant.DomLayer._detachDomManager(child, onchildadded, onchildremoved);\n        }\n    }\n    node._domManager.remove();\n    delete node._domManager;\n};\n\n/**\n * @scope enchant.CanvasLayer.prototype\n */\nenchant.CanvasLayer = enchant.Class.create(enchant.Group, {\n    /**\n     * @name enchant.CanvasLayer\n     * @class\n     * Class that uses the HTML Canvas for rendering.\n     * The rendering of children will be replaced by the Canvas rendering.\n     * @constructs\n     * @extends enchant.Group\n     */\n    initialize: function() {\n        var core = enchant.Core.instance;\n\n        enchant.Group.call(this);\n\n        this._cvsCache = {\n            matrix: [1, 0, 0, 1, 0, 0],\n            detectColor: '#000000'\n        };\n        this._cvsCache.layer = this;\n\n        this._element = document.createElement('canvas');\n        this._element.style.position = 'absolute';\n        // issue 179\n        this._element.style.left = this._element.style.top = '0px';\n\n        this._detect = document.createElement('canvas');\n        this._detect.style.position = 'absolute';\n        this._lastDetected = 0;\n\n        this.context = this._element.getContext('2d');\n        this._dctx = this._detect.getContext('2d');\n        this._setImageSmoothingEnable();\n\n        this._colorManager = new enchant.DetectColorManager(16, 256);\n\n        this.width = core.width;\n        this.height = core.height;\n\n        var touch = [\n            enchant.Event.TOUCH_START,\n            enchant.Event.TOUCH_MOVE,\n            enchant.Event.TOUCH_END\n        ];\n\n        touch.forEach(function(type) {\n            this.addEventListener(type, function(e) {\n                if (this._scene) {\n                    this._scene.dispatchEvent(e);\n                }\n            });\n        }, this);\n\n        var __onchildadded = function(e) {\n            var child = e.node;\n            var self = e.target;\n            var layer;\n            if (self instanceof enchant.CanvasLayer) {\n                layer = self._scene._layers.Canvas;\n            } else {\n                layer = self.scene._layers.Canvas;\n            }\n            enchant.CanvasLayer._attachCache(child, layer, __onchildadded, __onchildremoved);\n            var render = new enchant.Event(enchant.Event.RENDER);\n            if (self._dirty) {\n                self._updateCoordinate();\n            }\n            child._dirty = true;\n            enchant.Matrix.instance.stack.push(self._matrix);\n            enchant.CanvasRenderer.instance.render(layer.context, child, render);\n            enchant.Matrix.instance.stack.pop(self._matrix);\n        };\n\n        var __onchildremoved = function(e) {\n            var child = e.node;\n            var self = e.target;\n            var layer;\n            if (self instanceof enchant.CanvasLayer) {\n                layer = self._scene._layers.Canvas;\n            } else {\n                layer = self.scene._layers.Canvas;\n            }\n            enchant.CanvasLayer._detachCache(child, layer, __onchildadded, __onchildremoved);\n        };\n\n        this.addEventListener('childremoved', __onchildremoved);\n        this.addEventListener('childadded', __onchildadded);\n\n    },\n    /**\n     * The width of the CanvasLayer.\n     * @type Number\n     */\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            this._width = width;\n            this._element.width = this._detect.width = width;\n            this._setImageSmoothingEnable();\n        }\n    },\n    /**\n     * The height of the CanvasLayer.\n     * @type Number\n     */\n    height: {\n        get: function() {\n            return this._height;\n        },\n        set: function(height) {\n            this._height = height;\n            this._element.height = this._detect.height = height;\n            this._setImageSmoothingEnable();\n        }\n    },\n    addChild: function(node) {\n        this.childNodes.push(node);\n        node.parentNode = this;\n        var childAdded = new enchant.Event('childadded');\n        childAdded.node = node;\n        childAdded.next = null;\n        this.dispatchEvent(childAdded);\n        node.dispatchEvent(new enchant.Event('added'));\n    },\n    insertBefore: function(node, reference) {\n        var i = this.childNodes.indexOf(reference);\n        if (i !== -1) {\n            this.childNodes.splice(i, 0, node);\n            node.parentNode = this;\n            var childAdded = new enchant.Event('childadded');\n            childAdded.node = node;\n            childAdded.next = reference;\n            this.dispatchEvent(childAdded);\n            node.dispatchEvent(new enchant.Event('added'));\n        } else {\n            this.addChild(node);\n        }\n    },\n    /**\n     * @private\n     */\n    _startRendering: function() {\n        this.addEventListener('exitframe', this._onexitframe);\n        this._onexitframe();\n    },\n    /**\n     * @private\n     */\n    _stopRendering: function() {\n        this.removeEventListener('exitframe', this._onexitframe);\n        this._onexitframe();\n    },\n    _onexitframe: function() {\n        var core = enchant.Core.instance;\n        var ctx = this.context;\n        ctx.clearRect(0, 0, core.width, core.height);\n        var render = new enchant.Event(enchant.Event.RENDER);\n        enchant.CanvasRenderer.instance.render(ctx, this, render);\n    },\n    _determineEventTarget: function(e) {\n        return this._getEntityByPosition(e.x, e.y);\n    },\n    _getEntityByPosition: function(x, y) {\n        var core = enchant.Core.instance;\n        var ctx = this._dctx;\n        if (this._lastDetected < core.frame) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            enchant.CanvasRenderer.instance.detectRender(ctx, this);\n            this._lastDetected = core.frame;\n        }\n        var extra = enchant.ENV.COLOR_DETECTION_LEVEL - 1;\n        var rgba = ctx.getImageData(x - extra, y - extra, 1 + extra * 2, 1 + extra * 2).data;\n        return this._colorManager.getSpriteByColors(rgba);\n    },\n    _setImageSmoothingEnable: function() {\n        this._dctx.imageSmoothingEnabled =\n                this._dctx.msImageSmoothingEnabled =\n                this._dctx.mozImageSmoothingEnabled =\n                this._dctx.webkitImageSmoothingEnabled = false;\n    }\n});\n\nenchant.CanvasLayer._attachCache = function(node, layer, onchildadded, onchildremoved) {\n    var child;\n    if (!node._cvsCache) {\n        node._cvsCache = {};\n        node._cvsCache.matrix = [ 1, 0, 0, 1, 0, 0 ];\n        node._cvsCache.detectColor = 'rgba(' + layer._colorManager.attachDetectColor(node) + ')';\n        node.addEventListener('childadded', onchildadded);\n        node.addEventListener('childremoved', onchildremoved);\n    }\n    if (node.childNodes) {\n        for (var i = 0, l = node.childNodes.length; i < l; i++) {\n            child = node.childNodes[i];\n            enchant.CanvasLayer._attachCache(child, layer, onchildadded, onchildremoved);\n        }\n    }\n};\n\nenchant.CanvasLayer._detachCache = function(node, layer, onchildadded, onchildremoved) {\n    var child;\n    if (node._cvsCache) {\n        layer._colorManager.detachDetectColor(node);\n        node.removeEventListener('childadded', onchildadded);\n        node.removeEventListener('childremoved', onchildremoved);\n        delete node._cvsCache;\n    }\n    if (node.childNodes) {\n        for (var i = 0, l = node.childNodes.length; i < l; i++) {\n            child = node.childNodes[i];\n            enchant.CanvasLayer._detachCache(child, layer, onchildadded, onchildremoved);\n        }\n    }\n};\n\nenchant.CanvasRenderer = enchant.Class.create({\n    render: function(ctx, node, e) {\n        var width, height, child;\n        ctx.save();\n        node.dispatchEvent(e);\n        // transform\n        this.transform(ctx, node);\n        if (typeof node._visible === 'undefined' || node._visible) {\n            width = node.width;\n            height = node.height;\n            // composite\n            if (node.compositeOperation) {\n                ctx.globalCompositeOperation = node.compositeOperation;\n            }\n            ctx.globalAlpha = (typeof node._opacity === 'number') ? node._opacity : 1.0;\n            // render\n            if (node._backgroundColor) {\n                ctx.fillStyle = node._backgroundColor;\n                ctx.fillRect(0, 0, width, height);\n            }\n\n            if (node.cvsRender) {\n                node.cvsRender(ctx);\n            }\n\n            if (enchant.Core.instance._debug && node._debugColor) {\n                ctx.strokeStyle = node._debugColor;\n                ctx.strokeRect(0, 0, width, height);\n            }\n            if (node._clipping) {\n                ctx.beginPath();\n                ctx.rect(0, 0, width, height);\n                ctx.clip();\n            }\n            if (node.childNodes) {\n                for (var i = 0, l = node.childNodes.length; i < l; i++) {\n                    child = node.childNodes[i];\n                    this.render(ctx, child, e);\n                }\n            }\n        }\n        ctx.restore();\n        enchant.Matrix.instance.stack.pop();\n    },\n    detectRender: function(ctx, node) {\n        var width, height, child;\n        if (typeof node._visible === 'undefined' || node._visible) {\n            width = node.width;\n            height = node.height;\n            ctx.save();\n            this.transform(ctx, node);\n            ctx.fillStyle = node._cvsCache.detectColor;\n            if (node._touchEnabled) {\n                if (node.detectRender) {\n                    node.detectRender(ctx);\n                } else {\n                    ctx.fillRect(0, 0, width, height);\n                }\n            }\n            if (node._clipping) {\n                ctx.beginPath();\n                ctx.rect(0, 0, width, height);\n                ctx.clip();\n            }\n            if (node.childNodes) {\n                for (var i = 0, l = node.childNodes.length; i < l; i++) {\n                    child = node.childNodes[i];\n                    this.detectRender(ctx, child);\n                }\n            }\n            ctx.restore();\n            enchant.Matrix.instance.stack.pop();\n        }\n    },\n    transform: function(ctx, node) {\n        var matrix = enchant.Matrix.instance;\n        var stack = matrix.stack;\n        var newmat, ox, oy, vec;\n        if (node._dirty) {\n            matrix.makeTransformMatrix(node, node._cvsCache.matrix);\n            newmat = [];\n            matrix.multiply(stack[stack.length - 1], node._cvsCache.matrix, newmat);\n            node._matrix = newmat;\n            ox = (typeof node._originX === 'number') ? node._originX : node._width / 2 || 0;\n            oy = (typeof node._originY === 'number') ? node._originY : node._height / 2 || 0;\n            vec = [ ox, oy ];\n            matrix.multiplyVec(newmat, vec, vec);\n            node._offsetX = vec[0] - ox;\n            node._offsetY = vec[1] - oy;\n            node._dirty = false;\n        } else {\n            newmat = node._matrix;\n        }\n        stack.push(newmat);\n        ctx.setTransform.apply(ctx, newmat);\n    }\n});\nenchant.CanvasRenderer.instance = new enchant.CanvasRenderer();\n\n/**\n * @scope enchant.Scene.prototype\n */\nenchant.Scene = enchant.Class.create(enchant.Group, {\n    /**\n     * @name enchant.Scene\n     * @class\n     * Class that becomes the root of the display object tree.\n     * Child {@link Entity} objects are distributed to the Scene layer according to the drawing method.\n     * The DOM of each Scene layer has a ({@link enchant.DOMLayer} and  {@link enchant.CanvasLayer}) and is drawn using the Canvas.\n     * Scenes are drawn in the order that they are added.\n     *\n     * @example\n     * var scene = new Scene();\n     * scene.addChild(player);\n     * scene.addChild(enemy);\n     * core.pushScene(scene);\n     *\n     * @constructs\n     * @extends enchant.Group\n     */\n    initialize: function() {\n        var core = enchant.Core.instance;\n\n        // Call initialize method of enchant.Group\n        enchant.Group.call(this);\n\n        // All nodes (entities, groups, scenes) have reference to the scene that it belongs to.\n        this.scene = this;\n\n        this._backgroundColor = null;\n\n        // Create div tag which possesses its layers\n        this._element = document.createElement('div');\n        this._element.style.position = 'absolute';\n        this._element.style.overflow = 'hidden';\n        this._element.style[enchant.ENV.VENDOR_PREFIX + 'TransformOrigin'] = '0 0';\n\n        this._layers = {};\n        this._layerPriority = [];\n\n        this.addEventListener(enchant.Event.CHILD_ADDED, this._onchildadded);\n        this.addEventListener(enchant.Event.CHILD_REMOVED, this._onchildremoved);\n        this.addEventListener(enchant.Event.ENTER, this._onenter);\n        this.addEventListener(enchant.Event.EXIT, this._onexit);\n\n        var that = this;\n        this._dispatchExitframe = function() {\n            var layer;\n            for (var prop in that._layers) {\n                layer = that._layers[prop];\n                layer.dispatchEvent(new enchant.Event(enchant.Event.EXIT_FRAME));\n            }\n        };\n\n        this.addEventListener(enchant.Event.CORE_RESIZE, this._oncoreresize);\n\n        this._oncoreresize(core);\n    },\n    /**#nocode+*/\n    x: {\n        get: function() {\n            return this._x;\n        },\n        set: function(x) {\n            this._x = x;\n            for (var type in this._layers) {\n                this._layers[type].x = x;\n            }\n        }\n    },\n    y: {\n        get: function() {\n            return this._y;\n        },\n        set: function(y) {\n            this._y = y;\n            for (var type in this._layers) {\n                this._layers[type].y = y;\n            }\n        }\n    },\n    width: {\n        get: function() {\n            return this._width;\n        },\n        set: function(width) {\n            this._width = width;\n            for (var type in this._layers) {\n                this._layers[type].width = width;\n            }\n        }\n    },\n    height: {\n        get: function() {\n            return this._height;\n        },\n        set: function(height) {\n            this._height = height;\n            for (var type in this._layers) {\n                this._layers[type].height = height;\n            }\n        }\n    },\n    rotation: {\n        get: function() {\n            return this._rotation;\n        },\n        set: function(rotation) {\n            this._rotation = rotation;\n            for (var type in this._layers) {\n                this._layers[type].rotation = rotation;\n            }\n        }\n    },\n    scaleX: {\n        get: function() {\n            return this._scaleX;\n        },\n        set: function(scaleX) {\n            this._scaleX = scaleX;\n            for (var type in this._layers) {\n                this._layers[type].scaleX = scaleX;\n            }\n        }\n    },\n    scaleY: {\n        get: function() {\n            return this._scaleY;\n        },\n        set: function(scaleY) {\n            this._scaleY = scaleY;\n            for (var type in this._layers) {\n                this._layers[type].scaleY = scaleY;\n            }\n        }\n    },\n    backgroundColor: {\n        get: function() {\n            return this._backgroundColor;\n        },\n        set: function(color) {\n            this._backgroundColor = this._element.style.backgroundColor = color;\n        }\n    },\n    remove: function() {\n        this.clearEventListener();\n\n        while (this.childNodes.length > 0) {\n            this.childNodes[0].remove();\n        }\n\n        return enchant.Core.instance.removeScene(this);\n    },\n    /**#nocode-*/\n    _oncoreresize: function(e) {\n        this._element.style.width = e.width + 'px';\n        this.width = e.width;\n        this._element.style.height = e.height + 'px';\n        this.height = e.height;\n        this._element.style[enchant.ENV.VENDOR_PREFIX + 'Transform'] = 'scale(' + e.scale + ')';\n\n        for (var type in this._layers) {\n            this._layers[type].dispatchEvent(e);\n        }\n    },\n    addLayer: function(type, i) {\n        var core = enchant.Core.instance;\n        if (this._layers[type]) {\n            return;\n        }\n        var layer = new enchant[type + 'Layer']();\n        if (core.currentScene === this) {\n            layer._startRendering();\n        }\n        this._layers[type] = layer;\n        var element = layer._element;\n        if (typeof i === 'number') {\n            var nextSibling = this._element.childNodes[i];\n            if (nextSibling) {\n                this._element.insertBefore(element, nextSibling);\n            } else {\n                this._element.appendChild(element);\n            }\n            this._layerPriority.splice(i, 0, type);\n        } else {\n            this._element.appendChild(element);\n            this._layerPriority.push(type);\n        }\n        layer._scene = this;\n    },\n    _determineEventTarget: function(e) {\n        var layer, target;\n        for (var i = this._layerPriority.length - 1; i >= 0; i--) {\n            layer = this._layers[this._layerPriority[i]];\n            target = layer._determineEventTarget(e);\n            if (target) {\n                break;\n            }\n        }\n        if (!target) {\n            target = this;\n        }\n        return target;\n    },\n    _onchildadded: function(e) {\n        var child = e.node;\n        var next = e.next;\n        var target, i;\n        if (child._element) {\n            target = 'Dom';\n            i = 1;\n        } else {\n            target = 'Canvas';\n            i = 0;\n        }\n        if (!this._layers[target]) {\n            this.addLayer(target, i);\n        }\n        child._layer = this._layers[target];\n        this._layers[target].insertBefore(child, next);\n        child.parentNode = this;\n    },\n    _onchildremoved: function(e) {\n        var child = e.node;\n        child._layer.removeChild(child);\n        child._layer = null;\n    },\n    _onenter: function() {\n        for (var type in this._layers) {\n            this._layers[type]._startRendering();\n        }\n        enchant.Core.instance.addEventListener('exitframe', this._dispatchExitframe);\n    },\n    _onexit: function() {\n        for (var type in this._layers) {\n            this._layers[type]._stopRendering();\n        }\n        enchant.Core.instance.removeEventListener('exitframe', this._dispatchExitframe);\n    }\n});\n\n/**\n * @scope enchant.LoadingScene.prototype\n */\nenchant.LoadingScene = enchant.Class.create(enchant.Scene, {\n    /**\n     * @name enchant.LoadingScene\n     * @class\n     * Default loading scene. If you want to use your own loading animation, overwrite (don't inherit) this class.\n     * Referred from enchant.Core in default, as `new enchant.LoadingScene` etc.\n     *\n     * @example\n     * enchant.LoadingScene = enchant.Class.create(enchant.Scene, {\n     *     initialize: function() {\n     *         enchant.Scene.call(this);\n     *         this.backgroundColor = 'red';\n     *         // ...\n     *         this.addEventListener('progress', function(e) {\n     *             progress = e.loaded / e.total;\n     *         });\n     *         this.addEventListener('enterframe', function() {\n     *             // animation\n     *         });\n     *     }\n     * });\n     * @constructs\n     * @extends enchant.Scene\n     */\n    initialize: function() {\n        enchant.Scene.call(this);\n        this.backgroundColor = '#000';\n        var barWidth = this.width * 0.4 | 0;\n        var barHeight = this.width * 0.05 | 0;\n        var border = barWidth * 0.03 | 0;\n        var bar = new enchant.Sprite(barWidth, barHeight);\n        bar.disableCollection();\n        bar.x = (this.width - barWidth) / 2;\n        bar.y = (this.height - barHeight) / 2;\n        var image = new enchant.Surface(barWidth, barHeight);\n        image.context.fillStyle = '#fff';\n        image.context.fillRect(0, 0, barWidth, barHeight);\n        image.context.fillStyle = '#000';\n        image.context.fillRect(border, border, barWidth - border * 2, barHeight - border * 2);\n        bar.image = image;\n        var progress = 0, _progress = 0;\n        this.addEventListener('progress', function(e) {\n            // avoid #167 https://github.com/wise9/enchant.js/issues/177\n            progress = e.loaded / e.total * 1.0;\n        });\n        bar.addEventListener('enterframe', function() {\n            _progress *= 0.9;\n            _progress += progress * 0.1;\n            image.context.fillStyle = '#fff';\n            image.context.fillRect(border, 0, (barWidth - border * 2) * _progress, barHeight);\n        });\n        this.addChild(bar);\n        this.addEventListener('load', function(e) {\n            var core = enchant.Core.instance;\n            core.removeScene(core.loadingScene);\n            core.dispatchEvent(e);\n        });\n    }\n});\n\n/**\n * @scope enchant.CanvasScene.prototype\n */\nenchant.CanvasScene = enchant.Class.create(enchant.Scene, {\n    /**\n     * @name enchant.CanvasScene\n     * @class\n     * Scene to draw by the Canvas all of the children.\n     * @constructs\n     * @extends enchant.Scene\n     */\n    initialize: function() {\n        enchant.Scene.call(this);\n        this.addLayer('Canvas');\n    },\n    _determineEventTarget: function(e) {\n        var target = this._layers.Canvas._determineEventTarget(e);\n        if (!target) {\n            target = this;\n        }\n        return target;\n    },\n    _onchildadded: function(e) {\n        var child = e.node;\n        var next = e.next;\n        child._layer = this._layers.Canvas;\n        this._layers.Canvas.insertBefore(child, next);\n    },\n    _onenter: function() {\n        this._layers.Canvas._startRendering();\n        enchant.Core.instance.addEventListener('exitframe', this._dispatchExitframe);\n    },\n    _onexit: function() {\n        this._layers.Canvas._stopRendering();\n        enchant.Core.instance.removeEventListener('exitframe', this._dispatchExitframe);\n    }\n});\n\n/**\n * @scope enchant.DOMScene.prototype\n */\nenchant.DOMScene = enchant.Class.create(enchant.Scene, {\n    /**\n     * @name enchant.DOMScene\n     * @class\n     * Scene to draw by the DOM all of the children.\n     * @constructs\n     * @extends enchant.Scene\n     */\n    initialize: function() {\n        enchant.Scene.call(this);\n        this.addLayer('Dom');\n    },\n    _determineEventTarget: function(e) {\n        var target = this._layers.Dom._determineEventTarget(e);\n        if (!target) {\n            target = this;\n        }\n        return target;\n    },\n    _onchildadded: function(e) {\n        var child = e.node;\n        var next = e.next;\n        child._layer = this._layers.Dom;\n        this._layers.Dom.insertBefore(child, next);\n    },\n    _onenter: function() {\n        this._layers.Dom._startRendering();\n        enchant.Core.instance.addEventListener('exitframe', this._dispatchExitframe);\n    },\n    _onexit: function() {\n        this._layers.Dom._stopRendering();\n        enchant.Core.instance.removeEventListener('exitframe', this._dispatchExitframe);\n    }\n});\n\n/**\n * @scope enchant.Surface.prototype\n */\nenchant.Surface = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.Surface\n     * @class\n     * Class that wraps canvas elements.\n     *\n     * Can be used to set the {@link enchant.Sprite} and {@link enchant.Map}'s image properties to be displayed.\n     * If you wish to access Canvas API use the {@link enchant.Surface#context} property.\n     *\n     * @example\n     * // Creates Sprite that displays a circle.\n     * var ball = new Sprite(50, 50);\n     * var surface = new Surface(50, 50);\n     * surface.context.beginPath();\n     * surface.context.arc(25, 25, 25, 0, Math.PI*2, true);\n     * surface.context.fill();\n     * ball.image = surface;\n     *\n     * @param {Number} width Surface width.\n     * @param {Number} height Surface height.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function(width, height) {\n        enchant.EventTarget.call(this);\n\n        var core = enchant.Core.instance;\n\n        /**\n         * Surface width.\n         * @type Number\n         */\n        this.width = Math.ceil(width);\n        /**\n         * Surface height.\n         * @type Number\n         */\n        this.height = Math.ceil(height);\n        /**\n         * Surface drawing context.\n         * @type CanvasRenderingContext2D\n         */\n        this.context = null;\n\n        var id = 'enchant-surface' + core._surfaceID++;\n        if (document.getCSSCanvasContext) {\n            this.context = document.getCSSCanvasContext('2d', id, width, height);\n            this._element = this.context.canvas;\n            this._css = '-webkit-canvas(' + id + ')';\n            var context = this.context;\n        } else if (document.mozSetImageElement) {\n            this._element = document.createElement('canvas');\n            this._element.width = width;\n            this._element.height = height;\n            this._css = '-moz-element(#' + id + ')';\n            this.context = this._element.getContext('2d');\n            document.mozSetImageElement(id, this._element);\n        } else {\n            this._element = document.createElement('canvas');\n            this._element.width = width;\n            this._element.height = height;\n            this._element.style.position = 'absolute';\n            this.context = this._element.getContext('2d');\n\n            enchant.ENV.CANVAS_DRAWING_METHODS.forEach(function(name) {\n                var method = this.context[name];\n                this.context[name] = function() {\n                    method.apply(this, arguments);\n                    this._dirty = true;\n                };\n            }, this);\n        }\n    },\n    /**\n     * Returns 1 pixel from the Surface.\n     * @param {Number} x The pixel's x coordinates.\n     * @param {Number} y The pixel's y coordinates.\n     * @return {Number[]} An array that holds pixel information in [r, g, b, a] format.\n     */\n    getPixel: function(x, y) {\n        return this.context.getImageData(x, y, 1, 1).data;\n    },\n    /**\n     * Sets one pixel within the surface.\n     * @param {Number} x The pixel's x coordinates.\n     * @param {Number} y The pixel's y coordinates.\n     * @param {Number} r The pixel's red level.\n     * @param {Number} g The pixel's green level.\n     * @param {Number} b The pixel's blue level.\n     * @param {Number} a The pixel's transparency.\n     */\n    setPixel: function(x, y, r, g, b, a) {\n        var pixel = this.context.createImageData(1, 1);\n        pixel.data[0] = r;\n        pixel.data[1] = g;\n        pixel.data[2] = b;\n        pixel.data[3] = a;\n        this.context.putImageData(pixel, x, y);\n    },\n    /**\n     * Clears all Surface pixels and makes the pixels transparent.\n     */\n    clear: function() {\n        this.context.clearRect(0, 0, this.width, this.height);\n    },\n    /**\n     * Draws the content of the given Surface onto this surface.\n     *\n     * Wraps Canvas API drawImage and if multiple arguments are given,\n     * these are getting applied to the Canvas drawImage method.\n     *\n     * @example\n     * var src = core.assets['src.gif'];\n     * var dst = new Surface(100, 100);\n     * dst.draw(src);         // Draws source at (0, 0)\n     * dst.draw(src, 50, 50); // Draws source at (50, 50)\n     * // Draws just 30 horizontal and vertical pixels of source at (50, 50)\n     * dst.draw(src, 50, 50, 30, 30);\n     * // Takes the image content in src starting at (10,10) with a (Width, Height) of (40,40),\n     * // scales it and draws it in this surface at (50, 50) with a (Width, Height) of (30,30).\n     * dst.draw(src, 10, 10, 40, 40, 50, 50, 30, 30);\n     *\n     * @param {enchant.Surface} image Surface used in drawing.\n     */\n    draw: function(image) {\n        image = image._element;\n        if (arguments.length === 1) {\n            this.context.drawImage(image, 0, 0);\n        } else {\n            var args = arguments;\n            args[0] = image;\n            this.context.drawImage.apply(this.context, args);\n        }\n    },\n    /**\n     * Copies Surface.\n     * @return {enchant.Surface} The copied Surface.\n     */\n    clone: function() {\n        var clone = new enchant.Surface(this.width, this.height);\n        clone.draw(this);\n        return clone;\n    },\n    /**\n     * Creates a data URI scheme from this Surface.\n     * @return {String} The data URI scheme that identifies this Surface and\n     * can be used to include this Surface into a dom tree.\n     */\n    toDataURL: function() {\n        var src = this._element.src;\n        if (src) {\n            if (src.slice(0, 5) === 'data:') {\n                return src;\n            } else {\n                return this.clone().toDataURL();\n            }\n        } else {\n            return this._element.toDataURL();\n        }\n    }\n});\n\n/**\n * Loads an image and creates a Surface object out of it.\n *\n * It is not possible to access properties or methods of the {@link enchant.Surface#context}, or to call methods using the Canvas API -\n * like {@link enchant.Surface#draw}, {@link enchant.Surface#clear}, {@link enchant.Surface#getPixel}, {@link enchant.Surface#setPixel}.. -\n * of the wrapped image created with this method.\n * However, it is possible to use this surface to draw it to another surface using the {@link enchant.Surface#draw} method.\n * The resulting surface can then be manipulated. (when loading images in a cross-origin resource sharing environment,\n * pixel acquisition and other image manipulation might be limited).\n *\n * @param {String} src The file path of the image to be loaded.\n * @param {Function} callback on load callback.\n * @param {Function} [onerror] on error callback.\n * @static\n * @return {enchant.Surface} Surface\n */\nenchant.Surface.load = function(src, callback, onerror) {\n    var image = new Image();\n    var surface = Object.create(enchant.Surface.prototype, {\n        context: { value: null },\n        _css: { value: 'url(' + src + ')' },\n        _element: { value: image }\n    });\n    enchant.EventTarget.call(surface);\n    onerror = onerror || function() {};\n    surface.addEventListener('load', callback);\n    surface.addEventListener('error', onerror);\n    image.onerror = function() {\n        var e = new enchant.Event(enchant.Event.ERROR);\n        e.message = 'Cannot load an asset: ' + image.src;\n        enchant.Core.instance.dispatchEvent(e);\n        surface.dispatchEvent(e);\n    };\n    image.onload = function() {\n        surface.width = image.width;\n        surface.height = image.height;\n        surface.dispatchEvent(new enchant.Event('load'));\n    };\n    image.src = src;\n    return surface;\n};\nenchant.Surface._staticCanvas2DContext = document.createElement('canvas').getContext('2d');\n\nenchant.Surface._getPattern = function(surface, force) {\n    if (!surface._pattern || force) {\n        surface._pattern = this._staticCanvas2DContext.createPattern(surface._element, 'repeat');\n    }\n    return surface._pattern;\n};\n\nif (window.Deferred) {\n    enchant.Deferred = window.Deferred;\n} else {\n    /**\n     * @scope enchant.Deferred.prototype\n     */\n    enchant.Deferred = enchant.Class.create({\n        /**\n         * @name enchant.Deferred\n         * @class\n         * <br/>\n         * See: <a href=\"http://cho45.stfuawsc.com/jsdeferred/\">\n         * http://cho45.stfuawsc.com/jsdeferred/</a>\n         *\n         * @example\n         * enchant.Deferred\n         *     .next(function() {\n         *         return 42;\n         *     })\n         *     .next(function(n) {\n         *         console.log(n); // 42\n         *     })\n         *     .next(function() {\n         *         return core.load('img.png'); // wait loading\n         *     })\n         *     .next(function() {\n         *         var img = core.assets['img.png'];\n         *         console.log(img instanceof enchant.Surface); // true\n         *         throw new Error('!!!');\n         *     })\n         *     .next(function() {\n         *         // skip\n         *     })\n         *     .error(function(err) {\n         *          console.log(err.message); // !!!\n         *     });\n         *\n         * @constructs\n         */\n        initialize: function() {\n            this._succ = this._fail = this._next = this._id = null;\n            this._tail = this;\n        },\n        /**\n         * @param {Function} func\n         */\n        next: function(func) {\n            var q = new enchant.Deferred();\n            q._succ = func;\n            return this._add(q);\n        },\n        /**\n         * @param {Function} func\n         */\n        error: function(func) {\n            var q = new enchant.Deferred();\n            q._fail = func;\n            return this._add(q);\n        },\n        _add: function(queue) {\n            this._tail._next = queue;\n            this._tail = queue;\n            return this;\n        },\n        /**\n         * @param {*} arg\n         */\n        call: function(arg) {\n            var received;\n            var queue = this;\n            while (queue && !queue._succ) {\n                queue = queue._next;\n            }\n            if (!(queue instanceof enchant.Deferred)) {\n                return;\n            }\n            try {\n                received = queue._succ(arg);\n            } catch (e) {\n                return queue.fail(e);\n            }\n            if (received instanceof enchant.Deferred) {\n                enchant.Deferred._insert(queue, received);\n            } else if (queue._next instanceof enchant.Deferred) {\n                queue._next.call(received);\n            }\n        },\n        /**\n         * @param {*} arg\n         */\n        fail: function(arg) {\n            var result, err,\n                queue = this;\n            while (queue && !queue._fail) {\n                queue = queue._next;\n            }\n            if (queue instanceof enchant.Deferred) {\n                result = queue._fail(arg);\n                queue.call(result);\n            } else if (arg instanceof Error) {\n                throw arg;\n            } else {\n                err = new Error('failed in Deferred');\n                err.arg = arg;\n                throw err;\n            }\n        }\n    });\n    enchant.Deferred._insert = function(queue, ins) {\n        if (queue._next instanceof enchant.Deferred) {\n            ins._tail._next = queue._next;\n        }\n        queue._next = ins;\n    };\n    /**\n     * @param {Function} func\n     * @return {enchant.Deferred}\n     * @static\n     */\n    enchant.Deferred.next = function(func) {\n        var q = new enchant.Deferred().next(func);\n        q._id = setTimeout(function() { q.call(); }, 0);\n        return q;\n    };\n    /**\n     * @param {Object|enchant.Deferred[]} arg\n     * @return {enchant.Deferred}\n     *\n     * @example\n     * // array\n     * enchant.Deferred\n     *     .parallel([\n     *         enchant.Deferred.next(function() {\n     *             return 24;\n     *         }),\n     *         enchant.Deferred.next(function() {\n     *             return 42;\n     *         })\n     *     ])\n     *     .next(function(arg) {\n     *         console.log(arg); // [ 24, 42 ]\n     *     });\n     * // object\n     * enchant.Deferred\n     *     .parallel({\n     *         foo: enchant.Deferred.next(function() {\n     *             return 24;\n     *         }),\n     *         bar: enchant.Deferred.next(function() {\n     *             return 42;\n     *         })\n     *     })\n     *     .next(function(arg) {\n     *         console.log(arg.foo); // 24\n     *         console.log(arg.bar); // 42\n     *     });\n     *\n     * @static\n     */\n    enchant.Deferred.parallel = function(arg) {\n        var q = new enchant.Deferred();\n        q._id = setTimeout(function() { q.call(); }, 0);\n        var progress = 0;\n        var ret = (arg instanceof Array) ? [] : {};\n        var p = new enchant.Deferred();\n        for (var prop in arg) {\n            if (arg.hasOwnProperty(prop)) {\n                progress++;\n                /*jshint loopfunc:true */\n                (function(queue, name) {\n                    queue.next(function(arg) {\n                        progress--;\n                        ret[name] = arg;\n                        if (progress <= 0) {\n                            p.call(ret);\n                        }\n                    })\n                    .error(function(err) { p.fail(err); });\n                    if (typeof queue._id === 'number') {\n                        clearTimeout(queue._id);\n                    }\n                    queue._id = setTimeout(function() { queue.call(); }, 0);\n                }(arg[prop], prop));\n            }\n        }\n        if (!progress) {\n            p._id = setTimeout(function() { p.call(ret); }, 0);\n        }\n        return q.next(function() { return p; });\n    };\n}\n\n/**\n * @scope enchant.DOMSound.prototype\n */\nenchant.DOMSound = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.DOMSound\n     * @class\n     * Class to wrap audio elements.\n     *\n     * Safari, Chrome, Firefox, Opera, and IE all play MP3 files\n     * (Firefox and Opera play via Flash). WAVE files can be played on\n     * Safari, Chrome, Firefox, and Opera. When the browser is not compatible with\n     * the used codec the file will not play.\n     *\n     * Instances are created not via constructor but via {@link enchant.DOMSound.load}.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function() {\n        enchant.EventTarget.call(this);\n        /**\n         * Sound file duration (seconds).\n         * @type Number\n         */\n        this.duration = 0;\n        throw new Error(\"Illegal Constructor\");\n    },\n    /**\n     * Begin playing.\n     */\n    play: function() {\n        if (this._element) {\n            this._element.play();\n        }\n    },\n    /**\n     * Pause playback.\n     */\n    pause: function() {\n        if (this._element) {\n            this._element.pause();\n        }\n    },\n    /**\n     * Stop playing.\n     */\n    stop: function() {\n        this.pause();\n        this.currentTime = 0;\n    },\n    /**\n     * Create a copy of this Sound object.\n     * @return {enchant.DOMSound} Copied Sound.\n     */\n    clone: function() {\n        var clone;\n        if (this._element instanceof Audio) {\n            clone = Object.create(enchant.DOMSound.prototype, {\n                _element: { value: this._element.cloneNode(false) },\n                duration: { value: this.duration }\n            });\n        } else if (enchant.ENV.USE_FLASH_SOUND) {\n            return this;\n        } else {\n            clone = Object.create(enchant.DOMSound.prototype);\n        }\n        enchant.EventTarget.call(clone);\n        return clone;\n    },\n    /**\n     * Current playback position (seconds).\n     * @type Number\n     */\n    currentTime: {\n        get: function() {\n            return this._element ? this._element.currentTime : 0;\n        },\n        set: function(time) {\n            if (this._element) {\n                this._element.currentTime = time;\n            }\n        }\n    },\n    /**\n     * Volume. 0 (muted) ï½ž 1 (full volume).\n     * @type Number\n     */\n    volume: {\n        get: function() {\n            return this._element ? this._element.volume : 1;\n        },\n        set: function(volume) {\n            if (this._element) {\n                this._element.volume = volume;\n            }\n        }\n    }\n});\n\n/**\n * Loads an audio file and creates DOMSound object.\n * @param {String} src Path of the audio file to be loaded.\n * @param {String} [type] MIME Type of the audio file.\n * @param {Function} [callback] on load callback.\n * @param {Function} [onerror] on error callback.\n * @return {enchant.DOMSound} DOMSound\n * @static\n */\nenchant.DOMSound.load = function(src, type, callback, onerror) {\n    if (type == null) {\n        var ext = enchant.Core.findExt(src);\n        if (ext) {\n            type = 'audio/' + ext;\n        } else {\n            type = '';\n        }\n    }\n    type = type.replace('mp3', 'mpeg').replace('m4a', 'mp4');\n    callback = callback || function() {};\n    onerror = onerror || function() {};\n\n    var sound = Object.create(enchant.DOMSound.prototype);\n    enchant.EventTarget.call(sound);\n    sound.addEventListener('load', callback);\n    sound.addEventListener('error', onerror);\n    var audio = new Audio();\n    if (!enchant.ENV.SOUND_ENABLED_ON_MOBILE_SAFARI &&\n        enchant.ENV.VENDOR_PREFIX === 'webkit' && enchant.ENV.TOUCH_ENABLED) {\n        window.setTimeout(function() {\n            sound.dispatchEvent(new enchant.Event('load'));\n        }, 0);\n    } else {\n        if (!enchant.ENV.USE_FLASH_SOUND && audio.canPlayType(type)) {\n            audio.addEventListener('canplaythrough', function canplay() {\n                sound.duration = audio.duration;\n                sound.dispatchEvent(new enchant.Event('load'));\n                audio.removeEventListener('canplaythrough', canplay);\n            }, false);\n            audio.src = src;\n            audio.load();\n            audio.autoplay = false;\n            audio.onerror = function() {\n                var e = new enchant.Event(enchant.Event.ERROR);\n                e.message = 'Cannot load an asset: ' + audio.src;\n                enchant.Core.instance.dispatchEvent(e);\n                sound.dispatchEvent(e);\n            };\n            sound._element = audio;\n        } else if (type === 'audio/mpeg') {\n            var embed = document.createElement('embed');\n            var id = 'enchant-audio' + enchant.Core.instance._soundID++;\n            embed.width = embed.height = 1;\n            embed.name = id;\n            embed.src = 'sound.swf?id=' + id + '&src=' + src;\n            embed.allowscriptaccess = 'always';\n            embed.style.position = 'absolute';\n            embed.style.left = '-1px';\n            sound.addEventListener('load', function() {\n                Object.defineProperties(embed, {\n                    currentTime: {\n                        get: function() {\n                            return embed.getCurrentTime();\n                        },\n                        set: function(time) {\n                            embed.setCurrentTime(time);\n                        }\n                    },\n                    volume: {\n                        get: function() {\n                            return embed.getVolume();\n                        },\n                        set: function(volume) {\n                            embed.setVolume(volume);\n                        }\n                    }\n                });\n                sound._element = embed;\n                sound.duration = embed.getDuration();\n            });\n            enchant.Core.instance._element.appendChild(embed);\n            enchant.DOMSound[id] = sound;\n        } else {\n            window.setTimeout(function() {\n                sound.dispatchEvent(new enchant.Event('load'));\n            }, 0);\n        }\n    }\n    return sound;\n};\n\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;\n\n/**\n * @scope enchant.WebAudioSound.prototype\n */\nenchant.WebAudioSound = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.WebAudioSound\n     * @class\n     * Sound wrapper class for Web Audio API (supported on some webkit-based browsers)\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function() {\n        if (!window.AudioContext) {\n            throw new Error(\"This browser does not support WebAudio API.\");\n        }\n        enchant.EventTarget.call(this);\n        if (!enchant.WebAudioSound.audioContext) {\n          enchant.WebAudioSound.audioContext = new window.AudioContext();\n          enchant.WebAudioSound.destination = enchant.WebAudioSound.audioContext.destination;\n        }\n        this.context = enchant.WebAudioSound.audioContext;\n        this.src = this.context.createBufferSource();\n        this.buffer = null;\n        this._volume = 1;\n        this._currentTime = 0;\n        this._state = 0;\n        this.connectTarget = enchant.WebAudioSound.destination;\n    },\n    /**\n     * Begin playing.\n     * @param {Boolean} [dup=false] If true, Object plays new sound while keeps last sound.\n     */\n    play: function(dup) {\n        if (this._state === 1 && !dup) {\n            this.src.disconnect();\n        }\n        if (this._state !== 2) {\n            this._currentTime = 0;\n        }\n        var offset = this._currentTime;\n        var actx = this.context;\n        this.src = actx.createBufferSource();\n        if (actx.createGain != null) {\n            this._gain = actx.createGain();\n        } else {\n            this._gain = actx.createGainNode();\n        }\n        this.src.buffer = this.buffer;\n        this._gain.gain.value = this._volume;\n\n        this.src.connect(this._gain);\n        this._gain.connect(this.connectTarget);\n        if (this.src.start != null) {\n            this.src.start(0, offset, this.buffer.duration - offset - 1.192e-7);\n        } else {\n            this.src.noteGrainOn(0, offset, this.buffer.duration - offset - 1.192e-7);\n        }\n        this._startTime = actx.currentTime - this._currentTime;\n        this._state = 1;\n    },\n    /**\n     * Pause playback.\n     */\n    pause: function() {\n        var currentTime = this.currentTime;\n        if (currentTime === this.duration) {\n            return;\n        }\n        if (this.src.stop != null) {\n            this.src.stop(0);\n        } else {\n            this.src.noteOff(0);\n        }\n        this._currentTime = currentTime;\n        this._state = 2;\n    },\n    /**\n     * Stop playing.\n     */\n    stop: function() {\n        if (this.src.stop != null) {\n            this.src.stop(0);\n        } else {\n            this.src.noteOff(0);\n        }\n        this._state = 0;\n    },\n    /**\n     * Create a copy of this Sound object.\n     * @return {enchant.WebAudioSound} Copied Sound.\n     */\n    clone: function() {\n        var sound = new enchant.WebAudioSound();\n        sound.buffer = this.buffer;\n        return sound;\n    },\n    /**\n     * Sound file duration (seconds).\n     * @type Number\n     */\n    duration: {\n        get: function() {\n            if (this.buffer) {\n                return this.buffer.duration;\n            } else {\n                return 0;\n            }\n        }\n    },\n    /**\n     * Volume. 0 (muted) ï½ž 1 (full volume).\n     * @type Number\n     */\n    volume: {\n        get: function() {\n            return this._volume;\n        },\n        set: function(volume) {\n            volume = Math.max(0, Math.min(1, volume));\n            this._volume = volume;\n            if (this.src) {\n                this._gain.gain.value = volume;\n            }\n        }\n    },\n    /**\n     * Current playback position (seconds).\n     * @type Number\n     */\n    currentTime: {\n        get: function() {\n            return Math.max(0, Math.min(this.duration, this.src.context.currentTime - this._startTime));\n        },\n        set: function(time) {\n            this._currentTime = time;\n            if (this._state !== 2) {\n                this.play(false);\n            }\n        }\n    }\n});\n\n/**\n * Loads an audio file and creates WebAudioSound object.\n * @param {String} src Path of the audio file to be loaded.\n * @param {String} [type] MIME Type of the audio file.\n * @param {Function} [callback] on load callback.\n * @param {Function} [onerror] on error callback.\n * @return {enchant.WebAudioSound} WebAudioSound\n * @static\n */\nenchant.WebAudioSound.load = function(src, type, callback, onerror) {\n    var canPlay = (new Audio()).canPlayType(type);\n    var sound = new enchant.WebAudioSound();\n    callback = callback || function() {};\n    onerror = onerror || function() {};\n    sound.addEventListener(enchant.Event.LOAD, callback);\n    sound.addEventListener(enchant.Event.ERROR, onerror);\n    function dispatchErrorEvent() {\n        var e = new enchant.Event(enchant.Event.ERROR);\n        e.message = 'Cannot load an asset: ' + src;\n        enchant.Core.instance.dispatchEvent(e);\n        sound.dispatchEvent(e);\n    }\n    var actx, xhr;\n    if (canPlay === 'maybe' || canPlay === 'probably') {\n        actx = enchant.WebAudioSound.audioContext;\n        xhr = new XMLHttpRequest();\n        xhr.open('GET', src, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.onload = function() {\n            actx.decodeAudioData(xhr.response, function(buffer) {\n                sound.buffer = buffer;\n                sound.dispatchEvent(new enchant.Event(enchant.Event.LOAD));\n            }, dispatchErrorEvent);\n        };\n        xhr.onerror = dispatchErrorEvent;\n        xhr.send(null);\n    } else {\n        setTimeout(dispatchErrorEvent,  50);\n    }\n    return sound;\n};\n\nenchant.Sound = window.AudioContext && enchant.ENV.USE_WEBAUDIO ? enchant.WebAudioSound : enchant.DOMSound;\n\n/*\n * ============================================================================================\n * Easing Equations v2.0\n * September 1, 2003\n * (c) 2003 Robert Penner, all rights reserved.\n * This work is subject to the terms in http://www.robertpenner.com/easing_terms_of_use.html.\n * ============================================================================================\n */\n\n/**\n * @namespace\n * JavaScript translation of Robert Penner's \"Easing Equations\" library which is widely used in ActionScript.\n * \n * @param [t] the current time\n * @param [b] the property's initial value\n * @param [c] how much the value should change\n * @param [d] how much time should elapse before value is changed\n * \n * @return {Number}\n * <br/>\n * See: <a href=\"http://www.robertpenner.com/easing/\">\n * http://www.robertpenner.com/easing/</a>\n * <br/>\n * See: <a href=\"http://www.robertpenner.com/easing/penner_chapter7_tweening.pdf\">\n * http://www.robertpenner.com/easing/penner_chapter7_tweening.pdf</a>\n */\nenchant.Easing = {\n    LINEAR: function(t, b, c, d) {\n        return c * t / d + b;\n    },\n\n    SWING: function(t, b, c, d) {\n        return c * (0.5 - Math.cos(((t / d) * Math.PI)) / 2) + b;\n    },\n\n    // *** quad\n    QUAD_EASEIN: function(t, b, c, d) {\n        return c * (t /= d) * t + b;\n    },\n\n    QUAD_EASEOUT: function(t, b, c, d) {\n        return -c * (t /= d) * (t - 2) + b;\n    },\n\n    QUAD_EASEINOUT: function(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return c / 2 * t * t + b;\n        }\n        return -c / 2 * ((--t) * (t - 2) - 1) + b;\n    },\n\n    // *** cubic\n    CUBIC_EASEIN: function(t, b, c, d) {\n        return c * (t /= d) * t * t + b;\n    },\n\n    CUBIC_EASEOUT: function(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    },\n\n    CUBIC_EASEINOUT: function(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    },\n\n    // *** quart\n    QUART_EASEIN: function(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    },\n\n    QUART_EASEOUT: function(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    },\n\n    QUART_EASEINOUT: function(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    },\n\n    // *** quint\n    QUINT_EASEIN: function(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    },\n\n    QUINT_EASEOUT: function(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    },\n\n    QUINT_EASEINOUT: function(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    },\n\n    // *** sin\n    SIN_EASEIN: function(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    },\n\n    SIN_EASEOUT: function(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    },\n\n    SIN_EASEINOUT: function(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    },\n\n    // *** circ\n    CIRC_EASEIN: function(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    },\n\n    CIRC_EASEOUT: function(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    },\n\n    CIRC_EASEINOUT: function(t, b, c, d) {\n        if ((t /= d / 2) < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    },\n\n    // *** elastic\n    ELASTIC_EASEIN: function(t, b, c, d, a, p) {\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d) === 1) {\n            return b + c;\n        }\n\n        if (!p) {\n            p = d * 0.3;\n        }\n\n        var s;\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            s = p / (2 * Math.PI) * Math.asin(c / a);\n        }\n        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    },\n\n    ELASTIC_EASEOUT: function(t, b, c, d, a, p) {\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d) === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var s;\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            s = p / (2 * Math.PI) * Math.asin(c / a);\n        }\n        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);\n    },\n\n    ELASTIC_EASEINOUT: function(t, b, c, d, a, p) {\n        if (t === 0) {\n            return b;\n        }\n        if ((t /= d / 2) === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var s;\n        if (!a || a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            s = p / (2 * Math.PI) * Math.asin(c / a);\n        }\n        if (t < 1) {\n            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n        }\n        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;\n    },\n\n    // *** bounce\n    BOUNCE_EASEOUT: function(t, b, c, d) {\n        if ((t /= d) < (1 / 2.75)) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < (2 / 2.75)) {\n            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;\n        } else if (t < (2.5 / 2.75)) {\n            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;\n        }\n    },\n\n    BOUNCE_EASEIN: function(t, b, c, d) {\n        return c - enchant.Easing.BOUNCE_EASEOUT(d - t, 0, c, d) + b;\n    },\n\n    BOUNCE_EASEINOUT: function(t, b, c, d) {\n        if (t < d / 2) {\n            return enchant.Easing.BOUNCE_EASEIN(t * 2, 0, c, d) * 0.5 + b;\n        } else {\n            return enchant.Easing.BOUNCE_EASEOUT(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n        }\n\n    },\n\n    // *** back\n    BACK_EASEIN: function(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    },\n\n    BACK_EASEOUT: function(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    },\n\n    BACK_EASEINOUT: function(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        if ((t /= d / 2) < 1) {\n            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\n    },\n\n    // *** expo\n    EXPO_EASEIN: function(t, b, c, d) {\n        return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    },\n\n    EXPO_EASEOUT: function(t, b, c, d) {\n        return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    },\n\n    EXPO_EASEINOUT: function(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        if ((t /= d / 2) < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n};\n\n/**\n * @scope enchant.ActionEventTarget.prototype\n */\nenchant.ActionEventTarget = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.ActionEventTarget\n     * @class\n     * EventTarget which can change the context of event listeners.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function() {\n        enchant.EventTarget.apply(this, arguments);\n    },\n    dispatchEvent: function(e) {\n        var target = this.node ? this.node : this;\n\n        e.target = target;\n        e.localX = e.x - target._offsetX;\n        e.localY = e.y - target._offsetY;\n\n        if (this['on' + e.type] != null) {\n            this['on' + e.type].call(target, e);\n        }\n        var listeners = this._listeners[e.type];\n        if (listeners != null) {\n            listeners = listeners.slice();\n            for (var i = 0, len = listeners.length; i < len; i++) {\n                listeners[i].call(target, e);\n            }\n        }\n    }\n});\n\n/**\n * @scope enchant.Timeline.prototype\n */\nenchant.Timeline = enchant.Class.create(enchant.EventTarget, {\n    /**\n     * @name enchant.Timeline\n     * @class\n     * Time-line class.\n     * Class for managing the action.\n     *\n     * For one node to manipulate the timeline of one must correspond.\n Â Â Â Â * Time-line class has a method to add a variety of actions to himself,\n Â Â Â Â * entities can be animated and various operations by using these briefly.\n Â Â Â Â * You can choose time based and frame based(default) animation.\n     * @param {enchant.Node} node target node.\n     * @constructs\n     * @extends enchant.EventTarget\n     */\n    initialize: function(node) {\n        enchant.EventTarget.call(this);\n        this.node = node;\n        this.queue = [];\n        this.paused = false;\n        this.looped = false;\n        this.isFrameBased = true;\n        this._parallel = null;\n        this._activated = false;\n        this.addEventListener(enchant.Event.ENTER_FRAME, this._onenterframe);\n\n        var tl = this;\n        this._nodeEventListener = function(e) {\n            tl.dispatchEvent(e);\n        };\n    },\n    /**\n     * @private\n     */\n    _deactivateTimeline: function() {\n        if (this._activated) {\n            this._activated = false;\n            this.node.removeEventListener('enterframe', this._nodeEventListener);\n        }\n    },\n    /**\n     * @private\n     */\n    _activateTimeline: function() {\n        if (!this._activated && !this.paused) {\n            this.node.addEventListener(\"enterframe\", this._nodeEventListener);\n            this._activated = true;\n        }\n    },\n    /**\n     * @private\n     */\n    _onenterframe: function(evt) {\n        if (this.paused) {\n            return;\n        }\n\n        this.tick(this.isFrameBased ? 1 : evt.elapsed);\n    },\n    /**\n     */\n    setFrameBased: function() {\n        this.isFrameBased = true;\n    },\n    /**\n     */\n    setTimeBased: function() {\n        this.isFrameBased = false;\n    },\n    /**\n     */\n    next: function(remainingTime) {\n        var e, action = this.queue.shift();\n\n        if (action) {\n            e = new enchant.Event(\"actionend\");\n            e.timeline = this;\n            action.dispatchEvent(e);\n\n            e = new enchant.Event(\"removedfromtimeline\");\n            e.timeline = this;\n            action.dispatchEvent(e);\n\n            if (this.looped) {\n                this.add(action);\n            }\n        }\n\n        if (this.queue.length === 0) {\n            this._deactivateTimeline();\n            return;\n        }\n\n        if (remainingTime > 0 || (this.queue[0] && this.queue[0].time === 0)) {\n            var event = new enchant.Event(\"actiontick\");\n            event.elapsed = remainingTime;\n            event.timeline = this;\n            this.queue[0].dispatchEvent(event);\n        }\n    },\n    /**\n     * @param {Number} elapsed\n     */\n    tick: function(elapsed) {\n        if (this.queue.length > 0) {\n            var action = this.queue[0];\n            if (action.frame === 0) {\n                var f;\n                f = new enchant.Event(\"actionstart\");\n                f.timeline = this;\n                action.dispatchEvent(f);\n            }\n\n            var e = new enchant.Event(\"actiontick\");\n            e.timeline = this;\n            e.elapsed = elapsed;\n            action.dispatchEvent(e);\n        }\n    },\n    /**\n     * @param {enchant.Action} action\n     * @return {enchant.Timeline}\n     */\n    add: function(action) {\n        this._activateTimeline();\n        if (this._parallel) {\n            this._parallel.actions.push(action);\n            this._parallel = null;\n        } else {\n            this.queue.push(action);\n        }\n        action.frame = 0;\n\n        var e = new enchant.Event(\"addedtotimeline\");\n        e.timeline = this;\n        action.dispatchEvent(e);\n\n        e = new enchant.Event(\"actionadded\");\n        e.action = action;\n        this.dispatchEvent(e);\n\n        return this;\n    },\n    /**\n     * @param {Object} params\n     * @return {enchant.Timeline}\n     */\n    action: function(params) {\n        return this.add(new enchant.Action(params));\n    },\n    /**\n     * @param {Object} params\n     * @return {enchant.Timeline}\n     */\n    tween: function(params) {\n        return this.add(new enchant.Tween(params));\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    clear: function() {\n        var e = new enchant.Event(\"removedfromtimeline\");\n        e.timeline = this;\n\n        for (var i = 0, len = this.queue.length; i < len; i++) {\n            this.queue[i].dispatchEvent(e);\n        }\n        this.queue = [];\n        this._deactivateTimeline();\n        return this;\n    },\n    /**\n     * @param {Number} frames\n     * @return {enchant.Timeline}\n     */\n    skip: function(frames) {\n        var event = new enchant.Event(\"enterframe\");\n        if (this.isFrameBased) {\n            event.elapsed = 1;\n        } else {\n            event.elapsed = frames;\n            frames = 1;\n        }\n        while (frames--) {\n            this.dispatchEvent(event);\n        }\n        return this;\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    pause: function() {\n        if (!this.paused) {\n            this.paused = true;\n            this._deactivateTimeline();\n        }\n        return this;\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    resume: function() {\n        if (this.paused) {\n            this.paused = false;\n            this._activateTimeline();\n        }\n        return this;\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    loop: function() {\n        this.looped = true;\n        return this;\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    unloop: function() {\n        this.looped = false;\n        return this;\n    },\n    /**\n     * @param {Number} time\n     * @return {enchant.Timeline}\n     */\n    delay: function(time) {\n        return this.action({\n            time: time\n        });\n    },\n    /**\n     * @ignore\n     * @param {Number} time\n     */\n    wait: function(time) {\n        // reserved\n        return this;\n    },\n    /**\n     * @param {Function} func\n     * @return {enchant.Timeline}\n     */\n    then: function(func) {\n        return this.action({\n            onactiontick: function(evt) {\n                func.call(this);\n            },\n            // if time is 0, next action will be immediately executed\n            time: 0\n        });\n    },\n    /**\n     * @param {Function} func\n     * @return {enchant.Timeline}\n     */\n    exec: function(func) {\n        return this.then(func);\n    },\n    /**\n     * @param {Object} cue\n     * @return {enchant.Timeline}\n     */\n    cue: function(cue) {\n        var ptr = 0;\n        for (var frame in cue) {\n            if (cue.hasOwnProperty(frame)) {\n                this.delay(frame - ptr);\n                this.then(cue[frame]);\n                ptr = frame;\n            }\n        }\n        return this;\n    },\n    /**\n     * @param {Function} func\n     * @param {Number} time\n     * @return {enchant.Timeline}\n     */\n    repeat: function(func, time) {\n        return this.action({\n            onactiontick: function(evt) {\n                func.call(this);\n            },\n            time: time\n        });\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    and: function() {\n        var last = this.queue.pop();\n        if (last instanceof enchant.ParallelAction) {\n            this._parallel = last;\n            this.queue.push(last);\n        } else {\n            var parallel = new enchant.ParallelAction();\n            parallel.actions.push(last);\n            this.queue.push(parallel);\n            this._parallel = parallel;\n        }\n        return this;\n    },\n    /**\n     * @ignore\n     */\n    or: function() {\n        return this;\n    },\n    /**\n     * @ignore\n     */\n    doAll: function(children) {\n        return this;\n    },\n    /**\n     * @ignore\n     */\n    waitAll: function() {\n        return this;\n    },\n    /**\n     * @param {Function} func\n     * @return {enchant.Timeline}\n     */\n    waitUntil: function(func) {\n        return this.action({\n            onactiontick: function(evt) {\n                if (func.call(this)) {\n                    evt.timeline.next();\n                }\n            }\n        });\n    },\n    /**\n     * @param {Number} opacity\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    fadeTo: function(opacity, time, easing) {\n        return this.tween({\n            opacity: opacity,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    fadeIn: function(time, easing) {\n        return this.fadeTo(1, time, easing);\n    },\n    /**\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    fadeOut: function(time, easing) {\n        return this.fadeTo(0, time, easing);\n    },\n    /**\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    moveTo: function(x, y, time, easing) {\n        return this.tween({\n            x: x,\n            y: y,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} x\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    moveX: function(x, time, easing) {\n        return this.tween({\n            x: x,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} y\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    moveY: function(y, time, easing) {\n        return this.tween({\n            y: y,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    moveBy: function(x, y, time, easing) {\n        return this.tween({\n            x: function() {\n                return this.x + x;\n            },\n            y: function() {\n                return this.y + y;\n            },\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    hide: function() {\n        return this.then(function() {\n            this.opacity = 0;\n        });\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    show: function() {\n        return this.then(function() {\n            this.opacity = 1;\n        });\n    },\n    /**\n     * @return {enchant.Timeline}\n     */\n    removeFromScene: function() {\n        return this.then(function() {\n            this.parentNode.removeChild(this);\n        });\n    },\n    /**\n     * @param {Number} scaleX\n     * @param {Number} [scaleY]\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    scaleTo: function(scale, time, easing) {\n        var scaleX, scaleY;\n\n        if (typeof easing === \"number\") {\n            scaleX = arguments[0];\n            scaleY = arguments[1];\n            time = arguments[2];\n            easing = arguments[3];\n        } else {\n            scaleX = scaleY = scale;\n        }\n\n        return this.tween({\n            scaleX: scaleX,\n            scaleY: scaleY,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} scaleX\n     * @param {Number} [scaleY]\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    scaleBy: function(scale, time, easing) {\n        var scaleX, scaleY;\n\n        if (typeof easing === \"number\") {\n            scaleX = arguments[0];\n            scaleY = arguments[1];\n            time = arguments[2];\n            easing = arguments[3];\n        } else {\n            scaleX = scaleY = scale;\n        }\n\n        return this.tween({\n            scaleX: function() {\n                return this.scaleX * scaleX;\n            },\n            scaleY: function() {\n                return this.scaleY * scaleY;\n            },\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} deg\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    rotateTo: function(deg, time, easing) {\n        return this.tween({\n            rotation: deg,\n            time: time,\n            easing: easing\n        });\n    },\n    /**\n     * @param {Number} deg\n     * @param {Number} time\n     * @param {Function} [easing=enchant.Easing.LINEAR]\n     * @return {enchant.Timeline}\n     */\n    rotateBy: function(deg, time, easing) {\n        return this.tween({\n            rotation: function() {\n                return this.rotation + deg;\n            },\n            time: time,\n            easing: easing\n        });\n    }\n});\n\n/**\n * @scope enchant.Action.prototype\n */\nenchant.Action = enchant.Class.create(enchant.ActionEventTarget, {\n    /**\n     * @name enchant.Action\n     * @class\nÂ Â Â Â Â * Actions are units that make up the timeline.\nÂ Â Â Â  * It is a unit used to specify the action you want to perform.\nÂ Â Â Â  * \nÂ Â Â Â  * Actions that have been added to the timeline are performed in sequential order.\nÂ Â Â Â  * The transition from one action to the next occurs automatically \nÂ Â Â Â  * after the number of frames specified by the time parameter have elapsed.\nÂ Â Â Â  *\nÂ Â Â Â  * An actionstart event is fired when the action has started.\nÂ Â Â Â  * An actionend event is fired when the action has stopped.\nÂ Â Â Â  * For each frame that elapses, an actiontick event is fired.\nÂ Â Â Â  * \nÂ Â Â Â  * You can specify a listener for these events to perform specific events when they occur.\n     *\n     * @param {Object} param\n     * @param {Number} [param.time] The number of frames that the action will persist. For an infinite number set this to null.\n     * @param {Function} [param.onactionstart] Event listener for when the action is initiated.\n     * @param {Function} [param.onactiontick] Event listener for when the action has passed one frame.\n     * @param {Function} [param.onactionend] Event listener for when the action is finished.\n     * @constructs\n     * @extends enchant.ActionEventTarget\n     */\n    initialize: function(param) {\n        enchant.ActionEventTarget.call(this);\n        this.time = null;\n        this.frame = 0;\n        for (var key in param) {\n            if (param.hasOwnProperty(key)) {\n                if (param[key] != null) {\n                    this[key] = param[key];\n                }\n            }\n        }\n        var action = this;\n\n        this.timeline = null;\n        this.node = null;\n\n        this.addEventListener(enchant.Event.ADDED_TO_TIMELINE, function(evt) {\n            action.timeline = evt.timeline;\n            action.node = evt.timeline.node;\n            action.frame = 0;\n        });\n\n        this.addEventListener(enchant.Event.REMOVED_FROM_TIMELINE, function() {\n            action.timeline = null;\n            action.node = null;\n            action.frame = 0;\n        });\n\n        this.addEventListener(enchant.Event.ACTION_TICK, function(evt) {\n            var remaining = action.time - (action.frame + evt.elapsed);\n            if (action.time != null && remaining <= 0) {\n                action.frame = action.time;\n                evt.timeline.next(-remaining);\n            } else {\n                action.frame += evt.elapsed;\n            }\n        });\n\n    }\n});\n\n/**\n * @scope enchant.ParallelAction.prototype\n */\nenchant.ParallelAction = enchant.Class.create(enchant.Action, {\n    /**\n     * @name enchant.ParallelAction\n     * @class\n     * Actions to be executed in parallel.\n     * It's possible to have more than one child action.\n     * @constructs\n     * @extends enchant.Action\n     */\n    initialize: function(param) {\n        enchant.Action.call(this, param);\n        /**\n         * Children Actions.\n         * @type enchant.Action[]\n         */\n        this.actions = [];\n        /**\n         * Removed actions.\n         * @type enchant.Action[]\n         */\n        this.endedActions = [];\n        var that = this;\n\n        this.addEventListener(enchant.Event.ACTION_START, function(evt) {\n            for (var i = 0, len = that.actions.length; i < len; i++) {\n                that.actions[i].dispatchEvent(evt);\n            }\n        });\n\n        this.addEventListener(enchant.Event.ACTION_TICK, function(evt) {\n            var i, len, timeline = {\n                next: function(remaining) {\n                    var action = that.actions[i];\n                    that.actions.splice(i--, 1);\n                    len = that.actions.length;\n                    that.endedActions.push(action);\n\n                    var e = new enchant.Event(\"actionend\");\n                    e.timeline = this;\n                    action.dispatchEvent(e);\n\n                    e = new enchant.Event(\"removedfromtimeline\");\n                    e.timeline = this;\n                    action.dispatchEvent(e);\n                }\n            };\n\n            var e = new enchant.Event(\"actiontick\");\n            e.timeline = timeline;\n            e.elapsed = evt.elapsed;\n            for (i = 0, len = that.actions.length; i < len; i++) {\n                that.actions[i].dispatchEvent(e);\n            }\n\n            if (that.actions.length === 0) {\n                evt.timeline.next();\n            }\n        });\n\n        this.addEventListener(enchant.Event.ADDED_TO_TIMELINE, function(evt) {\n            for (var i = 0, len = that.actions.length; i < len; i++) {\n                that.actions[i].dispatchEvent(evt);\n            }\n        });\n\n        this.addEventListener(enchant.Event.REMOVED_FROM_TIMELINE, function() {\n            that.actions = that.endedActions;\n            that.endedActions = [];\n        });\n\n    }\n});\n\n/**\n * @scope enchant.Tween.prototype\n */\nenchant.Tween = enchant.Class.create(enchant.Action, {\n    /**\n     * @name enchant.Tween\n     * @class\n     * @param {Object} params\n     * @param {Number} params.time\n     * @param {Function} [params.easing=enchant.Easing.LINEAR]\n     * @constructs\n     * @extends enchant.Action\n     */\n    initialize: function(params) {\n        var origin = {};\n        var target = {};\n        enchant.Action.call(this, params);\n\n        if (this.easing == null) {\n            this.easing = enchant.Easing.LINEAR;\n        }\n\n        var tween = this;\n        this.addEventListener(enchant.Event.ACTION_START, function() {\n            // excepted property\n            var excepted = [\"frame\", \"time\", \"callback\", \"onactiontick\", \"onactionstart\", \"onactionend\"];\n            for (var prop in params) {\n                if (params.hasOwnProperty(prop)) {\n                    // if function is used instead of numerical value, evaluate it\n                    var target_val;\n                    if (typeof params[prop] === \"function\") {\n                        target_val = params[prop].call(tween.node);\n                    } else {\n                        target_val = params[prop];\n                    }\n\n                    if (excepted.indexOf(prop) === -1) {\n                        origin[prop] = tween.node[prop];\n                        target[prop] = target_val;\n                    }\n                }\n            }\n        });\n\n        this.addEventListener(enchant.Event.ACTION_TICK, function(evt) {\n            // if time is 0, set property to target value immediately\n            var ratio = tween.time === 0 ? 1 : tween.easing(Math.min(tween.time,tween.frame + evt.elapsed), 0, 1, tween.time) - tween.easing(tween.frame, 0, 1, tween.time);\n\n            for (var prop in target){\n                if (target.hasOwnProperty(prop)) {\n                    if (typeof this[prop] === \"undefined\"){\n                        continue;\n                    }\n                    tween.node[prop] += (target[prop] - origin[prop]) * ratio;\n                    if (Math.abs(tween.node[prop]) < 10e-8){\n                        tween.node[prop] = 0;\n                    }\n                }\n            }\n        });\n    }\n});\n\nconst ActionEventTarget = enchant.ActionEventTarget;\nconst BinaryInputManager = enchant.BinaryInputManager;\nconst BinaryInputSource = enchant.BinaryInputSource;\nconst CanvasLayer = enchant.CanvasLayer;\nconst CanvasScene = enchant.CanvasScene;\nconst Class = enchant.Class;\nconst Core = enchant.Core;\nconst Deferred = enchant.Deferred;\nconst DOMScene = enchant.DOMScene;\nconst DOMSound = enchant.DOMSound;\nconst Easing = enchant.Easing;\nconst Entity = enchant.Entity;\nconst ENV = enchant.ENV;\nconst Event = enchant.Event;\nconst EventTarget = enchant.EventTarget;\nconst Game = enchant.Game;\nconst Group = enchant.Group;\nconst InputManager = enchant.InputManager;\nconst InputSource = enchant.InputSource;\nconst KeyboardInputManager = enchant.KeyboardInputManager;\nconst KeyboardInputSource = enchant.KeyboardInputSource;\nconst Label = enchant.Label;\nconst LoadingScene = enchant.LoadingScene;\nconst Map = enchant.Map;\nconst Node = enchant.Node;\nconst ParallelAction = enchant.ParallelAction;\nconst Scene = enchant.Scene;\nconst Sprite = enchant.Sprite;\nconst Surface = enchant.Surface;\nconst Timeline = enchant.Timeline;\nconst Tween = enchant.Tween;\nconst WebAudioSound = enchant.WebAudioSound;\n\n\nclass CustomEvent extends enchant.Event {\n    constructor(type, eventInitDict) {\n        super(type);\n        if (eventInitDict === null ||\n            eventInitDict === undefined ||\n           typeof eventInitDict !== 'object'\n        ) {\n            return;\n        }\n        for (const key in eventInitDict) {\n            this[key] = eventInitDict[key];\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/../node_modules/enchant.js?\n}");

/***/ }),

/***/ "./src/adapter/IRepo.ts":
/*!******************************!*\
  !*** ./src/adapter/IRepo.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assetKeys: () => (/* binding */ assetKeys)\n/* harmony export */ });\nconst assetKeys = {\n    start: \"./assets/start.png\",\n    end: \"./assets/end.png\",\n    font1: \"./assets/font1.png\",\n    kuma1: \"./assets/chara1.png\",\n};\n\n\n//# sourceURL=webpack://ishitori/./src/adapter/IRepo.ts?\n}");

/***/ }),

/***/ "./src/adapter/in/GameController.ts":
/*!******************************************!*\
  !*** ./src/adapter/in/GameController.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameController: () => (/* binding */ GameController)\n/* harmony export */ });\n/* harmony import */ var enchant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! enchant.js */ \"../node_modules/enchant.js\");\n/* harmony import */ var _src_app_exporter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/app/exporter */ \"./src/app/exporter.ts\");\n/* harmony import */ var _src_common_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/common/config */ \"./src/common/config.ts\");\n/* harmony import */ var _IRepo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../IRepo */ \"./src/adapter/IRepo.ts\");\n/* harmony import */ var _out_Stage1SceneController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../out/Stage1SceneController */ \"./src/adapter/out/Stage1SceneController.ts\");\n/* harmony import */ var _out_TitleSceneController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../out/TitleSceneController */ \"./src/adapter/out/TitleSceneController.ts\");\n\n\n\n\n\n\nclass GameController {\n    static create() {\n        return new GameController();\n    }\n    constructor() {\n        this.core = createCore();\n        this.core.onload = () => {\n            this.engine.init();\n            this.core.onenterframe = e => this.onenterframe(e);\n        };\n        const repo = createRepo(this.core, e => this.ontouchstart(e));\n        this.engine = createEngine(repo);\n    }\n    core;\n    engine;\n    touchstart = undefined;\n    get input() {\n        return {\n            frame: this.core.frame,\n            touchstart: this.touchstart,\n        };\n    }\n    ;\n    onenterframe(e) {\n        try {\n            this.engine.tick(this.input);\n        }\n        catch (e) {\n            console.log(e);\n        }\n        finally {\n            this.touchstart = undefined;\n        }\n    }\n    ontouchstart(e) {\n        const touchstart = {\n            pos: { x: e.x, y: e.y },\n            localPos: { x: e.localX, y: e.localY },\n        };\n        this.touchstart = touchstart;\n    }\n    start() {\n        this.core.start();\n    }\n    pause() {\n        this.core.pause();\n    }\n    resume() {\n        this.core.resume();\n    }\n    stop() {\n        this.core.stop();\n    }\n}\nfunction createCore() {\n    const { width, height, fps, backgroundColor } = _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen;\n    const core = new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Core(width, height);\n    core.preload(Object.values(_IRepo__WEBPACK_IMPORTED_MODULE_3__.assetKeys));\n    core.fps = fps;\n    core.rootScene.backgroundColor = backgroundColor;\n    return core;\n}\nfunction createRepo(core, ontouchstart) {\n    return new class {\n        core = core;\n        fetchImg(key) {\n            return core.assets[key];\n        }\n        pushNewScene() {\n            const scene = new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Scene();\n            scene.ontouchstart = e => ontouchstart(e);\n            core.pushScene(scene);\n            return scene;\n        }\n    }();\n}\nfunction createEngine(repo) {\n    return (0,_src_app_exporter__WEBPACK_IMPORTED_MODULE_1__.createIGameEngine)({\n        Title: () => new _out_TitleSceneController__WEBPACK_IMPORTED_MODULE_5__.TitleSceneController(repo),\n        Stage1: () => new _out_Stage1SceneController__WEBPACK_IMPORTED_MODULE_4__.Stage1SceneController(repo),\n    });\n}\n\n\n//# sourceURL=webpack://ishitori/./src/adapter/in/GameController.ts?\n}");

/***/ }),

/***/ "./src/adapter/out/RectRange.ts":
/*!**************************************!*\
  !*** ./src/adapter/out/RectRange.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RectRange: () => (/* binding */ RectRange)\n/* harmony export */ });\nclass RectRange {\n    static fromLeftTopAndSize(left, top, width, height) {\n        return new RectRange(width >= 0 ? left : left + width, height >= 0 ? top : top + height, Math.abs(width), Math.abs(height));\n    }\n    constructor(left, top, width, height) {\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    left;\n    top;\n    width;\n    height;\n    get right() { return this.left + this.width; }\n    get bottom() { return this.top + this.height; }\n    contains(pos) {\n        const { x, y } = pos;\n        return this.left <= x &&\n            x <= this.right &&\n            this.top <= y &&\n            y <= this.bottom;\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/adapter/out/RectRange.ts?\n}");

/***/ }),

/***/ "./src/adapter/out/Stage1SceneController.ts":
/*!**************************************************!*\
  !*** ./src/adapter/out/Stage1SceneController.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stage1SceneController: () => (/* binding */ Stage1SceneController)\n/* harmony export */ });\n/* harmony import */ var enchant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! enchant.js */ \"../node_modules/enchant.js\");\n/* harmony import */ var _src_app_domain_model_PlayFieldW__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @src/app/domain/model/PlayFieldW */ \"./src/app/domain/model/PlayFieldW.ts\");\n/* harmony import */ var _src_common_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/common/config */ \"./src/common/config.ts\");\n/* harmony import */ var _src_common_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/common/util */ \"./src/common/util.ts\");\n/* harmony import */ var _RectRange__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectRange */ \"./src/adapter/out/RectRange.ts\");\n\n\n\n\n\nconst c_entities = {\n    maxNumPickTitle: {\n        text: \"ä¸€å›žã§å–ã‚Œã‚‹çŸ³ã®æ•°ï¼š\",\n        size: 40,\n        width: 40 * 10,\n        x: 10 + _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width * 0 / 9,\n        y: 10,\n    },\n    maxNumPickVal: {\n        text: \"\",\n        size: 40,\n        x: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width * 6 / 9,\n        y: 10,\n    },\n    numStonesTitle: {\n        text: \"çŸ³ã®æ•°ï¼š\",\n        size: 40,\n        x: 10 + _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width * 3 / 9 + 35,\n        y: 10 + 40,\n    },\n    numStonesVal: {\n        text: \"\",\n        size: 40,\n        x: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width * 6 / 9,\n        y: 10 + 40,\n    },\n    firstTurnTitle: {\n        text: \"å…ˆæ‰‹\",\n        size: 80,\n        color: \"black\",\n        backgroundColor: \"white\",\n        width: 80 * 2,\n        height: 80,\n        x: (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - 80 * 2) / 2,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 3 / 9,\n    },\n    secondTurnTitle: {\n        text: \"å¾Œæ‰‹\",\n        size: 80,\n        color: \"black\",\n        backgroundColor: \"white\",\n        width: 80 * 2,\n        height: 80,\n        x: (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - 80 * 2) / 2,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 5 / 9,\n    },\n    countdownVal: {\n        text: \"\",\n        size: 80,\n        color: \"black\",\n        backgroundColor: \"yellow\",\n        width: 80 * 3 / 4,\n        height: 80,\n        x: (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - 80 * 3 / 4) / 2,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 2 / 11,\n    },\n    numPickVal: {\n        text: \"\",\n        size: 80,\n        color: \"black\",\n        backgroundColor: \"white\",\n        width: 80 * 3 / 4,\n        height: 80,\n        x: 0,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 5 / 9,\n    },\n    winnerVal: {\n        text: \"\",\n        size: 80,\n        x: 0,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 4 / 9,\n    },\n    retryTitle: {\n        text: \"å†æˆ¦\",\n        size: 80,\n        color: \"black\",\n        backgroundColor: \"white\",\n        width: 80 * 2,\n        height: 80,\n        x: (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - 80 * 2) / 2,\n        y: _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height * 6 / 9,\n    },\n};\nconst c_states = {\n    \"OnCreated\": {},\n    \"OnWaitingInit\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(2),\n    },\n    \"OnWaitingUserSelectTurn\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(5),\n    },\n    \"OnUserSelectedTurn\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(1),\n    },\n    \"OnWaitingCpuFinishTurn\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(0.2),\n    },\n    \"OnWaitingUserFinishTurn\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(5),\n    },\n    \"OnPlayerFinishedTurn\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(1),\n    },\n    \"OnGameFinished\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(1),\n    },\n    \"OnWaitingUserSelectRetry\": {},\n    \"OnUserSelectedRetry\": {\n        waitingFrame: (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(1),\n    },\n    \"OnFinished\": {},\n};\nclass Stage1SceneController {\n    constructor(repo) {\n        this.repo = repo;\n        this.scene = this.repo.pushNewScene();\n    }\n    repo;\n    scene;\n    retryLabel = new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Label(\"å†æˆ¦ã™ã‚‹ï¼Ÿ\");\n    entities = Entities.create();\n    _input = { frame: 0 };\n    set input(v) {\n        this._input = v;\n    }\n    get pos() {\n        return this._input.touchstart?.pos;\n    }\n    randValFrom(vals) {\n        const random = Math.random();\n        const index = Math.floor(vals.length * random);\n        return vals[index];\n    }\n    fetchSelectedTurn() {\n        const pos = this.pos;\n        if (!pos) {\n            return undefined;\n        }\n        return this.entities.findSelectedTurnVal(pos);\n    }\n    fetchSelectedNumPick() {\n        const pos = this.pos;\n        if (!pos) {\n            return undefined;\n        }\n        return this.entities.findSelectedNumPickVal(pos);\n    }\n    isRetrySelected() {\n        const pos = this.pos;\n        if (!pos) {\n            return false;\n        }\n        return this.entities.findSelectedRetryTitle(pos);\n    }\n    isWaiting(status) {\n        if (\"frame\" in status) {\n            return status.frame < c_states[status.tag].waitingFrame;\n        }\n        return true;\n    }\n    drawScene(status) {\n        switch (status.tag) {\n            case \"OnCreated\":\n                throw new Error(\"here cannot be reached. status=\" + JSON.stringify(status));\n            case \"OnWaitingInit\": {\n                if (status.frame === 0) {\n                    this.entities.showNumStonesLabels(this.scene, status.playField.numStones);\n                }\n                if (status.frame === (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(1)) {\n                    this.entities.showMaxNumPickLabels(this.scene, status.playField.maxNumPick);\n                }\n                return;\n            }\n            case \"OnWaitingUserSelectTurn\": {\n                const remainingFrame = c_states[status.tag].waitingFrame - status.frame;\n                if (status.frame === 0) {\n                    this.entities.showTurnSelectionLabels(this.scene);\n                    this.entities.showCountdownLabel(this.scene, remainingFrame);\n                    return;\n                }\n                if (remainingFrame == 0) {\n                    this.entities.removeCountdownLabel();\n                    return;\n                }\n                if (remainingFrame % _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.fps != 0) {\n                    return;\n                }\n                this.entities.updateCountdownLabel(remainingFrame);\n                return;\n            }\n            case \"OnUserSelectedTurn\": {\n                if (status.frame === 0) {\n                    this.entities.removeCountdownLabel();\n                    this.entities.selectTurnVal(status.nextPlayer);\n                }\n                return;\n            }\n            case \"OnWaitingCpuFinishTurn\": {\n                if (status.frame === 0) {\n                    const numPickableStones = _src_app_domain_model_PlayFieldW__WEBPACK_IMPORTED_MODULE_1__.PlayFieldW\n                        .wrap(status.playField)\n                        .numPickableStones;\n                    this.entities.showNumPickLabels(this.scene, numPickableStones);\n                }\n                return;\n            }\n            case \"OnWaitingUserFinishTurn\": {\n                const remainingFrame = c_states[status.tag].waitingFrame - status.frame;\n                if (status.frame === 0) {\n                    const numPickableStones = _src_app_domain_model_PlayFieldW__WEBPACK_IMPORTED_MODULE_1__.PlayFieldW\n                        .wrap(status.playField)\n                        .numPickableStones;\n                    this.entities.showNumPickLabels(this.scene, numPickableStones);\n                    this.entities.showCountdownLabel(this.scene, remainingFrame);\n                    return;\n                }\n                if (remainingFrame == 0) {\n                    this.entities.removeCountdownLabel();\n                    return;\n                }\n                if (remainingFrame % _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.fps != 0) {\n                    return;\n                }\n                this.entities.updateCountdownLabel(remainingFrame);\n                return;\n            }\n            case \"OnPlayerFinishedTurn\": {\n                if (status.frame === 0) {\n                    this.entities.removeCountdownLabel();\n                    this.entities.selectNumPickVal(status.turn.numPick);\n                    this.entities.updateNumStonesLabel(status.playField.numStones);\n                }\n                return;\n            }\n            case \"OnGameFinished\": {\n                if (status.frame === 0) {\n                    this.entities.showWinnerLabel(this.scene, status.winner);\n                }\n                return;\n            }\n            case \"OnWaitingUserSelectRetry\": {\n                this.entities.showRetryLabel(this.scene);\n                return;\n            }\n            case \"OnUserSelectedRetry\": {\n                if (status.frame === 0) {\n                    this.entities.showCurtain(this.scene);\n                }\n                return;\n            }\n            case \"OnFinished\": {\n                this.scene.remove();\n                return;\n            }\n            default:\n                throw new Error(\"Not Implemented. status=\" + JSON.stringify(status));\n        }\n    }\n}\nclass Entities {\n    static create() {\n        return new this();\n    }\n    constructor() {\n        this.numStonesVal = Label1.create(c_entities.numStonesVal);\n        this.firstTurnVal = Label1.create(c_entities.firstTurnTitle);\n        this.secondTurnVal = Label1.create(c_entities.secondTurnTitle);\n        this.countdownVal = Label1.create(c_entities.countdownVal);\n        this.numPickVals = [];\n        this.retryTitle = Label1.create(c_entities.retryTitle);\n    }\n    numStonesVal;\n    firstTurnVal;\n    secondTurnVal;\n    countdownVal;\n    numPickVals;\n    retryTitle;\n    showMaxNumPickLabels(scene, maxNumPick) {\n        {\n            const a = Label1.create(c_entities.maxNumPickTitle);\n            scene.addChild(a);\n        }\n        {\n            const a = Label1.create(c_entities.maxNumPickVal);\n            a.text = `${maxNumPick}`;\n            scene.addChild(a);\n        }\n    }\n    showNumStonesLabels(scene, numStones) {\n        {\n            const a = Label1.create(c_entities.numStonesTitle);\n            scene.addChild(a);\n        }\n        {\n            const a = this.numStonesVal;\n            a.text = `${numStones}`;\n            scene.addChild(a);\n        }\n    }\n    updateNumStonesLabel(numStones) {\n        this.numStonesVal.text = `${numStones}`;\n    }\n    showTurnSelectionLabels(scene) {\n        scene.addChild(this.firstTurnVal);\n        scene.addChild(this.secondTurnVal);\n    }\n    findSelectedTurnVal(pos) {\n        if (this.firstTurnVal.contains(pos)) {\n            return \"MAN\";\n        }\n        if (this.secondTurnVal.contains(pos)) {\n            return \"CPU\";\n        }\n        return undefined;\n    }\n    selectTurnVal(nextPlayer) {\n        const [selected, not] = nextPlayer === \"MAN\"\n            ? [this.firstTurnVal, this.secondTurnVal]\n            : [this.secondTurnVal, this.firstTurnVal];\n        new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Timeline(selected)\n            .fadeOut(c_states.OnUserSelectedTurn.waitingFrame)\n            .then(() => selected.remove());\n        not.remove();\n    }\n    showCountdownLabel(scene, remainingFrame) {\n        this.countdownVal.text = `${remainingFrame / _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.fps}`;\n        scene.addChild(this.countdownVal);\n    }\n    updateCountdownLabel(remainingFrame) {\n        this.countdownVal.text = `${remainingFrame / _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.fps}`;\n    }\n    removeCountdownLabel() {\n        this.countdownVal.remove();\n    }\n    showNumPickLabels(scene, numPickableStones) {\n        const space = 5;\n        const width = (c_entities.numPickVal.width + space) * numPickableStones;\n        const left = (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - width) / 2;\n        for (const i of (0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.seq)(0, numPickableStones)) {\n            const a = Label1.create(c_entities.numPickVal);\n            a.text = `${i + 1}`;\n            a.x = left + (a.width + space) * i;\n            this.numPickVals.push(a);\n            scene.addChild(a);\n        }\n    }\n    findSelectedNumPickVal(pos) {\n        for (const a of this.numPickVals) {\n            if (a.contains(pos)) {\n                return Number.parseInt(a.text);\n            }\n        }\n        return undefined;\n    }\n    selectNumPickVal(numPick) {\n        for (const a of this.numPickVals.splice(0)) {\n            const num = Number.parseInt(a.text);\n            if (num !== numPick) {\n                a.remove();\n                continue;\n            }\n            new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Timeline(a)\n                .fadeOut(c_states.OnPlayerFinishedTurn.waitingFrame)\n                .then(() => a.remove());\n        }\n    }\n    showWinnerLabel(scene, winner) {\n        const text = winner === \"MAN\"\n            ? `ã‚ãªãŸã®å‹ã¡`\n            : `ã‚ãªãŸã®è² ã‘`;\n        const width = c_entities.winnerVal.size * text.length;\n        const a = Label1.create(c_entities.winnerVal);\n        a.text = text;\n        a.width = width;\n        a.x = (_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width - width) / 2;\n        scene.addChild(a);\n    }\n    showRetryLabel(scene) {\n        scene.addChild(this.retryTitle);\n    }\n    findSelectedRetryTitle(pos) {\n        return this.retryTitle.contains(pos);\n    }\n    showCurtain(scene) {\n        const a = new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Sprite(_src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.width, _src_common_config__WEBPACK_IMPORTED_MODULE_2__.config.screen.height);\n        a.backgroundColor = \"black\";\n        a.opacity = 0;\n        scene.addChild(a);\n        new enchant_js__WEBPACK_IMPORTED_MODULE_0__.Timeline(a).fadeIn((0,_src_common_util__WEBPACK_IMPORTED_MODULE_3__.secToFrame)(0.9));\n    }\n}\nclass Label1 extends enchant_js__WEBPACK_IMPORTED_MODULE_0__.Label {\n    static create(p) {\n        const text = p.text ?? \"\";\n        const a = new this(text);\n        const size = p.size ?? 10;\n        a.font = `${size}px 'Meiryo', 'ãƒ¡ã‚¤ãƒªã‚ª', 'ãƒ’ãƒ©ã‚®ãƒŽè§’ã‚´ Pro W3', sans-serif`;\n        a.color = p.color ?? \"black\";\n        a.backgroundColor = p.backgroundColor ?? \"transparent\";\n        if (!!p.width) {\n            a.width = p.width;\n        }\n        if (!!p.height) {\n            a.height = p.height;\n        }\n        a.x = p.x ?? 0;\n        a.y = p.y ?? 0;\n        return a;\n    }\n    constructor(text) {\n        super(text);\n    }\n    contains(pos) {\n        const r = _RectRange__WEBPACK_IMPORTED_MODULE_4__.RectRange\n            .fromLeftTopAndSize(this.x, this.y, this.width, this.height);\n        return r.contains(pos);\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/adapter/out/Stage1SceneController.ts?\n}");

/***/ }),

/***/ "./src/adapter/out/TitleSceneController.ts":
/*!*************************************************!*\
  !*** ./src/adapter/out/TitleSceneController.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TitleSceneController: () => (/* binding */ TitleSceneController)\n/* harmony export */ });\n/* harmony import */ var enchant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! enchant.js */ \"../node_modules/enchant.js\");\n\nclass TitleSceneController {\n    constructor(repo) {\n        this.repo = repo;\n        this.scene = this.repo.pushNewScene();\n    }\n    repo;\n    scene;\n    sqSps = [];\n    labels = [];\n    marks = [];\n    _input = { frame: 0 };\n    set input(v) {\n        this._input = v;\n    }\n    drawScene(event) {\n        switch (event.tag) {\n            case \"OnSceneAdded\": return this.onSceneAdded(event);\n            case \"OnSceneRemoved\": return this.onSceneRemoved(event);\n            default: { }\n        }\n    }\n    onSceneAdded(event) {\n    }\n    onSceneRemoved(event) {\n        this.scene.remove();\n    }\n}\nclass SqSp extends enchant_js__WEBPACK_IMPORTED_MODULE_0__.Sprite {\n    constructor(range) {\n        super(range.width - 2, range.height - 2);\n        this.x = range.left + 1;\n        this.y = range.top + 1;\n        this.backgroundColor = \"white\";\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/adapter/out/TitleSceneController.ts?\n}");

/***/ }),

/***/ "./src/app/domain/GameEngine.ts":
/*!**************************************!*\
  !*** ./src/app/domain/GameEngine.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameEngine: () => (/* binding */ GameEngine)\n/* harmony export */ });\n/* harmony import */ var _SceneStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SceneStack */ \"./src/app/domain/SceneStack.ts\");\n/* harmony import */ var _scene_Stage1Scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene/Stage1Scene */ \"./src/app/domain/scene/Stage1Scene.ts\");\n\n\nclass GameEngine {\n    static create(controllerFactories) {\n        const sceneStack = _SceneStack__WEBPACK_IMPORTED_MODULE_0__.SceneStack.create(controllerFactories);\n        return new GameEngine(sceneStack);\n    }\n    constructor(sceneStack) {\n        this.sceneStack = sceneStack;\n    }\n    sceneStack;\n    init() {\n        const scene = _scene_Stage1Scene__WEBPACK_IMPORTED_MODULE_1__.Stage1Scene.create({ gameMode: 1 });\n        this.sceneStack.push(scene);\n    }\n    tick(input) {\n        this.sceneStack.tickTop(input);\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/GameEngine.ts?\n}");

/***/ }),

/***/ "./src/app/domain/SceneStack.ts":
/*!**************************************!*\
  !*** ./src/app/domain/SceneStack.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SceneStack: () => (/* binding */ SceneStack)\n/* harmony export */ });\nclass SceneStack {\n    static create(controllerFactories) {\n        return new SceneStack(controllerFactories);\n    }\n    constructor(controllerFactories) {\n        this.controllerFactories = controllerFactories;\n    }\n    controllerFactories;\n    stack = [];\n    push(scene) {\n        const controller = this.controllerFactories[scene.name]();\n        const sceneSet = { scene, controller };\n        this.stack.push(sceneSet);\n        sceneSet.scene.onAdded(\n        // @ts-ignore\n        sceneSet.controller);\n        // this.tickTop({});\n    }\n    pop() {\n        const sceneSet = this.stack.pop();\n        if (sceneSet === undefined) {\n            return;\n        }\n        sceneSet.scene.onRemoved(\n        // @ts-ignore\n        sceneSet.controller);\n    }\n    tickTop(input) {\n        const len = this.stack.length;\n        if (len <= 0) {\n            return;\n        }\n        const sceneSet = this.stack[len - 1];\n        const result = this.tickTopImpl(sceneSet, input);\n        if (result.finished ?? false) {\n            this.pop();\n        }\n        if (result.next !== undefined) {\n            this.push(result.next);\n        }\n    }\n    tickTopImpl(sceneSet, input) {\n        const beforeProps = this.beforeLog(sceneSet.scene, input);\n        try {\n            const controller = sceneSet.controller;\n            controller.input = input;\n            return sceneSet.scene.onTick(\n            // @ts-ignore\n            controller);\n        }\n        catch (e) {\n            console.error(e);\n            return { finished: true };\n        }\n        finally {\n            this.afterLog(sceneSet.scene, beforeProps);\n        }\n    }\n    beforeLog(scene, input) {\n        const beforeProps = JSON.stringify(scene.props);\n        if (!!input.touchstart) {\n            const props = JSON.stringify(scene.props);\n            console.log(`beforeTick: props=${props}, input=${JSON.stringify(input)}`);\n        }\n        return beforeProps;\n    }\n    afterLog(scene, beforeProps) {\n        const afterProps = JSON.stringify(scene.props);\n        if (beforeProps != afterProps) {\n            const props = JSON.stringify(scene.props);\n            console.log(`afterTick: props=${props}`);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/SceneStack.ts?\n}");

/***/ }),

/***/ "./src/app/domain/model/Cpu1.ts":
/*!**************************************!*\
  !*** ./src/app/domain/model/Cpu1.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cpu1: () => (/* binding */ Cpu1)\n/* harmony export */ });\n/* harmony import */ var _src_common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/common/util */ \"./src/common/util.ts\");\n/* harmony import */ var _PlayFieldW__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PlayFieldW */ \"./src/app/domain/model/PlayFieldW.ts\");\n\n\nclass Cpu1 {\n    static create() {\n        return new Cpu1();\n    }\n    constructor() {\n    }\n    selectTurn(playField) {\n        const { maxNumPick, numStones } = playField;\n        return (numStones - 1) % (maxNumPick + 1) !== 0\n            ? \"CPU\"\n            : \"MAN\";\n    }\n    selectNumPickCandidates(playField) {\n        const { maxNumPick, numStones } = playField;\n        if ((numStones - 1) % (maxNumPick + 1) !== 0) {\n            const c = Math.floor((numStones - 1) / (maxNumPick + 1));\n            const numPick = (numStones - 1) - c * (maxNumPick + 1);\n            return [numPick];\n        }\n        const numPickableStones = _PlayFieldW__WEBPACK_IMPORTED_MODULE_1__.PlayFieldW\n            .wrap(playField)\n            .numPickableStones;\n        return [...(0,_src_common_util__WEBPACK_IMPORTED_MODULE_0__.seq)(1, numPickableStones + 1)];\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/model/Cpu1.ts?\n}");

/***/ }),

/***/ "./src/app/domain/model/PlayFieldW.ts":
/*!********************************************!*\
  !*** ./src/app/domain/model/PlayFieldW.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayFieldW: () => (/* binding */ PlayFieldW)\n/* harmony export */ });\n/* harmony import */ var _src_common_ResultOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/common/ResultOf */ \"./src/common/ResultOf.ts\");\n\nclass PlayFieldW {\n    static create() {\n        return new PlayFieldW({\n            maxNumPick: 4,\n            numStones: 15,\n        });\n    }\n    static wrap(playField) {\n        return new PlayFieldW(playField);\n    }\n    constructor(playField) {\n        this.playField = playField;\n    }\n    playField;\n    get numPickableStones() {\n        const { maxNumPick, numStones } = this.playField;\n        if (numStones <= 0) {\n            return undefined;\n        }\n        return Math.min(maxNumPick, numStones);\n    }\n    removeStones(num) {\n        if (this.numPickableStones === undefined) {\n            const msg = `stones not exists.`;\n            return _src_common_ResultOf__WEBPACK_IMPORTED_MODULE_0__.ResultOf.err(new Error(msg));\n        }\n        const max = Math.min(this.playField.numStones, this.playField.maxNumPick);\n        if (num < 1 ||\n            max < num) {\n            const msg = `numPick must be between [1 .. ${max}], but is ${num}.`;\n            return _src_common_ResultOf__WEBPACK_IMPORTED_MODULE_0__.ResultOf.err(new Error(msg));\n        }\n        return _src_common_ResultOf__WEBPACK_IMPORTED_MODULE_0__.ResultOf.ok({\n            ...this.playField,\n            numStones: this.playField.numStones - num,\n        });\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/model/PlayFieldW.ts?\n}");

/***/ }),

/***/ "./src/app/domain/model/PlayerW.ts":
/*!*****************************************!*\
  !*** ./src/app/domain/model/PlayerW.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerW: () => (/* binding */ PlayerW)\n/* harmony export */ });\nclass PlayerW {\n    static wrap(player) {\n        return new PlayerW(player);\n    }\n    constructor(player) {\n        this.player = player;\n    }\n    player;\n    get opponent() {\n        return this.player === \"MAN\" ? \"CPU\" : \"MAN\";\n    }\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/model/PlayerW.ts?\n}");

/***/ }),

/***/ "./src/app/domain/scene/Stage1Scene.ts":
/*!*********************************************!*\
  !*** ./src/app/domain/scene/Stage1Scene.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stage1Scene: () => (/* binding */ Stage1Scene)\n/* harmony export */ });\n/* harmony import */ var _src_common_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/common/util */ \"./src/common/util.ts\");\n/* harmony import */ var _model_Cpu1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Cpu1 */ \"./src/app/domain/model/Cpu1.ts\");\n/* harmony import */ var _model_PlayFieldW__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/PlayFieldW */ \"./src/app/domain/model/PlayFieldW.ts\");\n/* harmony import */ var _model_PlayerW__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/PlayerW */ \"./src/app/domain/model/PlayerW.ts\");\n\n\n\n\nconst name = \"Stage1\";\nclass Stage1Scene {\n    static create(data) {\n        return new this(data);\n    }\n    constructor(data) {\n        this._props = {\n            gameMode: data.gameMode,\n            status: { tag: \"OnCreated\" },\n        };\n    }\n    _props;\n    get name() {\n        return name;\n    }\n    get props() {\n        return this._props;\n    }\n    updateProps(next) {\n        this._props = {\n            ...this._props,\n            ...next,\n        };\n        return this._props;\n    }\n    onAdded(controller) {\n        // controller.drawScene({\n        //     tag: \"OnCreated\",\n        // });\n    }\n    onRemoved(controller) {\n        // controller.drawScene({\n        //     tag: \"OnFinished\",\n        // });\n    }\n    onTick(controller) {\n        const curr = this.props;\n        const nextStatus = tick(controller, curr);\n        const next = this.updateProps({\n            status: nextStatus\n        });\n        controller.drawScene(next.status);\n        if (next.status.tag === \"OnFinished\") {\n            return {\n                finished: true,\n                next: Stage1Scene.create(this.props),\n            };\n        }\n        else {\n            return {};\n        }\n    }\n}\nconst c = {\n    maxNumPickCands: [...(0,_src_common_util__WEBPACK_IMPORTED_MODULE_0__.seq)(2, 9)],\n    turnsCands: [...(0,_src_common_util__WEBPACK_IMPORTED_MODULE_0__.seq)(5, 9)],\n};\nfunction tick(controller, curr) {\n    const status = curr.status;\n    switch (status.tag) {\n        case \"OnCreated\": {\n            const playField = createPlayField(controller);\n            return createOnWaitingInit(playField);\n        }\n        case \"OnWaitingInit\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            return toOnWaitingUserSelectTurn(status);\n        }\n        case \"OnWaitingUserSelectTurn\": {\n            const selectedU = controller.fetchSelectedTurn();\n            if (!!selectedU) {\n                return toOnUserSelectedTurn(status, selectedU);\n            }\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            const selectedC = _model_Cpu1__WEBPACK_IMPORTED_MODULE_1__.Cpu1\n                .create()\n                .selectTurn(status.playField);\n            return toOnUserSelectedTurn(status, selectedC);\n        }\n        case \"OnUserSelectedTurn\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            if (status.nextPlayer === \"CPU\") {\n                return toOnWaitingCpuFinishTurn(status);\n            }\n            else {\n                return toOnWaitingUserFinishTurn(status);\n            }\n        }\n        case \"OnWaitingCpuFinishTurn\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            const cands = _model_Cpu1__WEBPACK_IMPORTED_MODULE_1__.Cpu1\n                .create()\n                .selectNumPickCandidates(status.playField);\n            const numPick = controller.randValFrom(cands);\n            return toOnPlayerFinishedTurn(status, \"CPU\", numPick);\n        }\n        case \"OnWaitingUserFinishTurn\": {\n            const selected = controller.fetchSelectedNumPick();\n            if (!!selected) {\n                return toOnPlayerFinishedTurn(status, \"MAN\", selected);\n            }\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            const numPickableStones = _model_PlayFieldW__WEBPACK_IMPORTED_MODULE_2__.PlayFieldW\n                .wrap(status.playField)\n                .numPickableStones;\n            const arr = [...(0,_src_common_util__WEBPACK_IMPORTED_MODULE_0__.seq)(1, numPickableStones + 1)];\n            const numPick = controller.randValFrom(arr);\n            return toOnPlayerFinishedTurn(status, \"MAN\", numPick);\n        }\n        case \"OnPlayerFinishedTurn\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            const playFieldW = _model_PlayFieldW__WEBPACK_IMPORTED_MODULE_2__.PlayFieldW.wrap(status.playField);\n            if (!playFieldW.numPickableStones) {\n                const winner = _model_PlayerW__WEBPACK_IMPORTED_MODULE_3__.PlayerW.wrap(status.turn.player).opponent;\n                return createOnGameFinished(winner);\n            }\n            if (status.turn.player === \"CPU\") {\n                return toOnWaitingUserFinishTurn(status);\n            }\n            else {\n                return toOnWaitingCpuFinishTurn(status);\n            }\n        }\n        case \"OnGameFinished\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            return createOnWaitingUserSelectRetry();\n        }\n        case \"OnWaitingUserSelectRetry\": {\n            const selected = controller.isRetrySelected();\n            if (!!selected) {\n                return createOnUserSelectedRetry();\n            }\n            return status;\n        }\n        case \"OnUserSelectedRetry\": {\n            if (controller.isWaiting(status)) {\n                return incFrame(status);\n            }\n            return {\n                tag: \"OnFinished\",\n            };\n        }\n        default:\n            throw new Error(\"Not Implemented. status=\" + status);\n    }\n}\nfunction incFrame(curr) {\n    if (\"frame\" in curr) {\n        return {\n            ...curr,\n            frame: curr.frame + 1,\n        };\n    }\n    return curr;\n}\nfunction createPlayField(controller) {\n    const maxNumPick = controller.randValFrom(c.maxNumPickCands);\n    const randRemains = [...(0,_src_common_util__WEBPACK_IMPORTED_MODULE_0__.seq)(0, maxNumPick)];\n    const numStones = maxNumPick * controller.randValFrom(c.turnsCands) +\n        controller.randValFrom(randRemains);\n    return {\n        maxNumPick,\n        numStones,\n    };\n}\nfunction createOnWaitingInit(playField) {\n    return {\n        tag: \"OnWaitingInit\",\n        playField,\n        frame: 0,\n    };\n}\nfunction toOnWaitingUserSelectTurn(curr) {\n    return {\n        tag: \"OnWaitingUserSelectTurn\",\n        playField: curr.playField,\n        frame: 0,\n    };\n}\nfunction toOnUserSelectedTurn(curr, nextPlayer) {\n    return {\n        tag: \"OnUserSelectedTurn\",\n        playField: curr.playField,\n        nextPlayer,\n        frame: 0,\n    };\n}\nfunction toOnWaitingCpuFinishTurn(curr) {\n    return {\n        tag: \"OnWaitingCpuFinishTurn\",\n        playField: curr.playField,\n        frame: 0,\n    };\n}\nfunction toOnWaitingUserFinishTurn(curr) {\n    return {\n        tag: \"OnWaitingUserFinishTurn\",\n        playField: curr.playField,\n        frame: 0,\n    };\n}\nfunction toOnPlayerFinishedTurn(curr, player, numPick) {\n    return {\n        tag: \"OnPlayerFinishedTurn\",\n        playField: {\n            ...curr.playField,\n            numStones: curr.playField.numStones - numPick,\n        },\n        turn: {\n            player,\n            numPick,\n        },\n        frame: 0,\n    };\n}\nfunction createOnGameFinished(winner) {\n    return {\n        tag: \"OnGameFinished\",\n        winner,\n        frame: 0,\n    };\n}\nfunction createOnWaitingUserSelectRetry() {\n    return {\n        tag: \"OnWaitingUserSelectRetry\",\n    };\n}\nfunction createOnUserSelectedRetry() {\n    return {\n        tag: \"OnUserSelectedRetry\",\n        frame: 0,\n    };\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/domain/scene/Stage1Scene.ts?\n}");

/***/ }),

/***/ "./src/app/exporter.ts":
/*!*****************************!*\
  !*** ./src/app/exporter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createIGameEngine: () => (/* binding */ createIGameEngine)\n/* harmony export */ });\n/* harmony import */ var _domain_GameEngine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domain/GameEngine */ \"./src/app/domain/GameEngine.ts\");\n\nfunction createIGameEngine(controllerFactories) {\n    return _domain_GameEngine__WEBPACK_IMPORTED_MODULE_0__.GameEngine.create(controllerFactories);\n}\n\n\n//# sourceURL=webpack://ishitori/./src/app/exporter.ts?\n}");

/***/ }),

/***/ "./src/common/ResultOf.ts":
/*!********************************!*\
  !*** ./src/common/ResultOf.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResultOf: () => (/* binding */ ResultOf)\n/* harmony export */ });\nclass ResultOf {\n    static ok(ok) {\n        return new ResultOf(ok);\n    }\n    static err(err) {\n        return new ResultOf(undefined, err);\n    }\n    constructor(ok, err) {\n        this.ok = ok;\n        this.err = err;\n    }\n    ok;\n    err;\n}\n\n\n//# sourceURL=webpack://ishitori/./src/common/ResultOf.ts?\n}");

/***/ }),

/***/ "./src/common/config.ts":
/*!******************************!*\
  !*** ./src/common/config.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\nconst config = {\n    screen: {\n        width: 600,\n        height: 600,\n        fps: 60,\n        backgroundColor: \"grey\",\n    },\n    title: {\n        fontSize: 50,\n        curtainingSec: 0.3,\n    },\n    stage: {\n        timer: 30,\n        width: 10,\n        height: 20,\n    },\n    block: {\n        width: 5,\n        height: 5,\n    },\n};\n\n\n//# sourceURL=webpack://ishitori/./src/common/config.ts?\n}");

/***/ }),

/***/ "./src/common/util.ts":
/*!****************************!*\
  !*** ./src/common/util.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSceneError: () => (/* binding */ createSceneError),\n/* harmony export */   randfloat: () => (/* binding */ randfloat),\n/* harmony export */   secToFrame: () => (/* binding */ secToFrame),\n/* harmony export */   seq: () => (/* binding */ seq),\n/* harmony export */   sleepAsync: () => (/* binding */ sleepAsync)\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/common/config.ts\");\n\nasync function sleepAsync(millis) {\n    await new Promise(resolve => setTimeout(resolve, millis));\n}\nfunction* seq(startInclusive, endExclusive) {\n    for (let i = startInclusive; i < endExclusive; i++) {\n        yield i;\n    }\n}\nfunction randfloat(min, max) {\n    return Math.random() * (max - min) + min;\n}\nfunction createSceneError(cause, props) {\n    const causeMsg = cause.message ?? cause;\n    const propsMsg = JSON.stringify(props);\n    const message = `cause=${causeMsg}, props=${propsMsg}`;\n    return new Error(message);\n}\nfunction secToFrame(sec) {\n    return Math.round(sec * _config__WEBPACK_IMPORTED_MODULE_0__.config.screen.fps);\n}\n\n\n//# sourceURL=webpack://ishitori/./src/common/util.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var enchant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! enchant.js */ \"../node_modules/enchant.js\");\n/* harmony import */ var _adapter_in_GameController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adapter/in/GameController */ \"./src/adapter/in/GameController.ts\");\n\n\n(0,enchant_js__WEBPACK_IMPORTED_MODULE_0__.enchant)();\nenchant_js__WEBPACK_IMPORTED_MODULE_0__.ENV.TOUCH_ENABLED = true;\nwindow.onload = () => {\n    const controller = _adapter_in_GameController__WEBPACK_IMPORTED_MODULE_1__.GameController.create();\n    window.onblur = () => controller.pause();\n    window.onfocus = () => controller.resume();\n    controller.start();\n};\n\n\n//# sourceURL=webpack://ishitori/./src/index.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;